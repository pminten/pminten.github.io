
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Parallelism in Elixir - A Cauldron of Black and White Stones</title>
  <meta name="author" content="Peter Minten">

  
  <meta name="description" content="Parallelization is something that comes up more and more now that processors get
more and more cores. In this blog post I will take a look at how &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://pminten.github.io/blog/2013/10/29/parallelism-in-elixir">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="A Cauldron of Black and White Stones" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">A Cauldron of Black and White Stones</a></h1>
  
    <h2>Peter Minten's blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://www.duckduckgo.com/" method="get">
  <fieldset role="search">
    <input type="hidden" name="sites" value="pminten.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search&hellip;"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Parallelism in Elixir</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-29T13:39:00+01:00" pubdate data-updated="true">Oct 29<span>th</span>, 2013</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Parallelization is something that comes up more and more now that processors get
more and more cores. In this blog post I will take a look at how Elixir supports
parallelism.</p>

<p>First the usual lecture on parallelism and concurrency. These are often mixed
up, probably because traditionally to get parallelism you needed to work with
the tools of concurrency (threads and mutexes and all that jazz).</p>

<p>Parallelism is fundamentally about taking something you can do in a sequential
(one process/thread) program and making it faster by doing parts of it at the
same time. Concurrency on the other hand is about making things possible that
are impossible in a sequential program.</p>

<p>For example when you have a function that blocks until it receives input from
the keyboard and a function that blocks until it receives input from the network
and you want to watch for both you&rsquo;re going to need multiple threads/processes
and thus concurrency (assuming there&rsquo;s no <code>select(3)</code> or something available).</p>

<p>On the other hand it&rsquo;s easy to count the words in a giant file sequentially, in
just a single process/thread. But if you can split up the file and have multiple
workers each count part of the file and those workers can run all at the same
time (in parallel) you can get your result much faster.</p>

<p>When working with parallelism you ideally want to convert a sequential algorithm
into a parallel one <em>without changing the semantics</em>. Now the bad news, in
Elixir this will not work. In Haskell it will. Haskell has deterministic
parallelism, Elixir doesn&rsquo;t. Well, technically Haskell doesn&rsquo;t have
deterministic parallelism (that&rsquo;s simply impossible to do with how computers
work) but it&rsquo;s so good at hiding the non-determinism that for all intents and
purposes it has deterministic parallelism.</p>

<p>In Elixir we don&rsquo;t quite have it so easy as Haskell programmers. We have to make
do with the tools that Erlang gives us. Ok, that&rsquo;s perhaps not the worst fate.
Erlang supports concurrency quite well (understatement of the century) and with
concurrency we can build parallelism.</p>

<h2>A simple parallel word count</h2>

<p>Let&rsquo;s think about parallel word count. How can we implement it using the tools
of Elixir? First, consider how the algorithm works:</p>

<ol>
<li>Divide the input lines into equally sized groups.</li>
<li>For each of the groups, in parallel, count the number of words.</li>
<li>Sum the results.</li>
</ol>


<p>This is actually quite a well known pattern: divide-map-reduce. Any time you
hear somebody talk about MapReduce this is the fundamental idea behind it:
divide the work, map it to workers and reduce the results. There&rsquo;s more to it
than that of course, but fundamentally it&rsquo;s this simple.</p>

<p>Now, how can we map (pardon the pun) these steps to Elixir code? Dividing is
fairly easy, because addition is commutative (<code>a + b == b + a</code>) we can simply
split the lines into N lists like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">def</span> <span class="n">divide</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_divide</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="no">List</span><span class="o">.</span><span class="n">duplicate</span><span class="p">([],</span> <span class="n">n</span><span class="p">),</span> <span class="p">[])</span>
</span><span class='line'>
</span><span class='line'><span class="k">defp</span> <span class="n">do_divide</span><span class="p">([],</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">o1</span> <span class="o">++</span> <span class="n">o2</span>
</span><span class='line'><span class="k">defp</span> <span class="n">do_divide</span><span class="p">([</span><span class="n">l</span><span class="o">|</span><span class="n">ls</span><span class="p">],</span> <span class="p">[</span><span class="n">o</span><span class="o">|</span><span class="n">o1</span><span class="p">],</span> <span class="n">o2</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_divide</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="p">[[</span><span class="n">l</span><span class="o">|</span><span class="n">o</span><span class="p">]</span><span class="o">|</span><span class="n">o2</span><span class="p">])</span>
</span><span class='line'><span class="k">defp</span> <span class="n">do_divide</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="p">[],</span> <span class="n">o2</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_divide</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="p">[])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Running <code>divide([1,2,3,4,5,6,7,8,9,10], 3)</code> gives <code>[[8, 5, 2], [7, 6, 1], [10,
9, 4, 3]]</code>, so the lines are neatly divided. Ok, order is weird but we&rsquo;ve already
seen that that doesn&rsquo;t matter (addition is commutative). Compared to the obvious
solution of slicing the list into equal pieces we don&rsquo;t need the length, which
means this algorithm will be easier to adapt to a form that works with any
enumerable. Mostly though it&rsquo;s because I learned functional programming in
Haskell and this algorithm works well with lazyness. :)</p>

<p>For each of these groups of lines we&rsquo;ll want to spawn a worker.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">def</span> <span class="n">parcount_spawn</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="n">master</span> <span class="o">=</span> <span class="n">self</span><span class="p">()</span>
</span><span class='line'>  <span class="no">Enum</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="k">fn</span> <span class="n">group</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="no">Process</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="k">fn</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="c1"># Gotta love closures: group is captured</span>
</span><span class='line'>      <span class="c1"># (If only I could do that so easily for the white Go groups)</span>
</span><span class='line'>      <span class="n">count</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="err">&amp;</span><span class="n">length</span><span class="p">(</span><span class="n">split_words</span><span class="p">(</span><span class="nv">&amp;1</span><span class="p">)))</span>
</span><span class='line'>              <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="err">&amp;</span><span class="p">(</span><span class="nv">&amp;1</span><span class="o">+</span><span class="nv">&amp;2</span><span class="p">))</span>
</span><span class='line'>      <span class="n">master</span> <span class="o">&lt;-</span> <span class="n">count</span>
</span><span class='line'>    <span class="k">end</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">defp</span> <span class="n">split_words</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="p">[]</span> <span class="c1"># String.split gives [&quot;&quot;] in this case</span>
</span><span class='line'><span class="k">defp</span> <span class="n">split_words</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">String</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Each of the workers counts the words in the lines in its group, sums them and
sends the count to the master process (the one that spawned the workers).</p>

<p>All that remains is to collect the subtotals and sum them.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">def</span> <span class="n">parcount_collect</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="n">n</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="n">_</span><span class="p">,</span> <span class="n">total</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="k">receive</span> <span class="k">do</span>
</span><span class='line'><span class="k">      </span><span class="n">count</span> <span class="o">-&gt;</span> <span class="n">total</span> <span class="o">+</span> <span class="n">count</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here the reduce of a range is a bit of a trick in order to go into <code>receive</code> a
specific number of times.</p>

<p>To put it all together:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">def</span> <span class="n">parcount</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="n">groups</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="n">parcount_spawn</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
</span><span class='line'>  <span class="n">parcount_collect</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>When we pass <code>parcount(["A", "B C", " ", "D D D ", ""], 3)</code> it neatly gives us
<code>6</code>.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Peter Minten</span></span>

      








  


<time datetime="2013-10-29T13:39:00+01:00" pubdate data-updated="true">Oct 29<span>th</span>, 2013</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/elixir/'>elixir</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/09/14/thinking-in-elixir-hide-your-messages/" title="Previous Post: Thinking in Elixir: Hide Your Messages">&laquo; Thinking in Elixir: Hide Your Messages</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/10/29/parallelism-in-elixir/">Parallelism in Elixir</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/14/thinking-in-elixir-hide-your-messages/">Thinking in Elixir: Hide Your Messages</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/12/elixir-patterns-abstract-data-structures/">Elixir Patterns: Abstract Data Structures</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/11/elixir-patterns-mixins/">Elixir Patterns: Mixins</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/05/elixirs-enumerable/">Elixir's Enumerable</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Peter Minten -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
