<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: elixir | A Cauldron of Black and White Stones]]></title>
  <link href="http://pminten.github.io/blog/categories/elixir/atom.xml" rel="self"/>
  <link href="http://pminten.github.io/"/>
  <updated>2013-10-01T11:26:56+02:00</updated>
  <id>http://pminten.github.io/</id>
  <author>
    <name><![CDATA[Peter Minten]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Thinking in Elixir: Hide Your Messages]]></title>
    <link href="http://pminten.github.io/blog/2013/09/14/thinking-in-elixir-hide-your-messages/"/>
    <updated>2013-09-14T13:39:00+02:00</updated>
    <id>http://pminten.github.io/blog/2013/09/14/thinking-in-elixir-hide-your-messages</id>
    <content type="html"><![CDATA[<p>In this new blog series I will try to explain some of the concepts behind
programming in Elixir. This will be less practical oriented than my Elixir
Patterns series and more focussed on the big ideas of functional concurrent
programming as supported by Elixir.</p>

<h2>Interface, messages and implementation</h2>

<p>Elixir is a language in which concurrency is done by passing messages between
processes. However in practical code it&rsquo;s actually pretty rare to see explicit
message passing. For example say we&rsquo;re working on a chat server. A chat room
could be written somewhat like this, using
<a href="https://github.com/pragdave/otp_dsl">otp_dsl</a>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">Chatroom</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="kn">use</span> <span class="no">OtpDsl</span><span class="o">.</span><span class="no">GenServer</span><span class="p">,</span> <span class="ss">initial_state:</span> <span class="no">HashDict</span><span class="o">.</span><span class="n">new</span><span class="p">()</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">defcall</span> <span class="n">enter</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">users</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2"> has entered the room&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1"># _from is secretly filled in by defcall and contains the PID of the caller</span>
</span><span class='line'><span class="n">reply</span><span class="p">(</span><span class="ss">:ok</span><span class="p">,</span> <span class="no">Dict</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">_from</span><span class="p">))</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">defcall</span> <span class="n">leave</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">users</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">d</span> <span class="o">=</span> <span class="no">Dict</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'><span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2"> has left the room&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">reply</span><span class="p">(</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">defcall</span> <span class="n">message</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</span><span class='line'><span class="n">reply</span><span class="p">(</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">defp</span> <span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="no">Enum</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="no">Dict</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">users</span><span class="p">),</span> <span class="no">User</span><span class="o">.</span><span class="n">send_line</span><span class="p">(</span><span class="err">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="m">1</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<!-- more -->


<p>This is a simple gen_server which has an API of three calls:</p>

<ul>
<li><code>enter(name)</code></li>
<li><code>leave(name)</code></li>
<li><code>message(name, message)</code></li>
</ul>


<p>When <code>enter</code> is called the chatroom adds the user to the list of users. The PID
of the sender is associated with the name (used in <code>send_all</code> to send a message
to all users). Because of how otp_dsl currently works the process gets the
local name <code>chatroom</code>.</p>

<p>If you look at the above code do you notice something? There are no messages in
sight. Of course this is a bit of a trick since the whole point of otp_dsl is
to simplify implementing OTP behaviours like gen_server. This is how the code
would look when using the normal Elixir <code>GenServer.Behaviour</code>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">Chatroom2</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="kn">use</span> <span class="no">GenServer</span><span class="o">.</span><span class="no">Behaviour</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">## Interface&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">enter</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1"># Normally I&#39;d allow a PID of the gen_server to call to be passed along but</span>
</span><span class='line'><span class="c1"># in order to keep this code compatible with the otp_dsl variant (which</span>
</span><span class='line'><span class="c1"># does&#39;t currently support that) we&#39;ll have to write it this way.</span>
</span><span class='line'><span class="ss">:gen_server</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="ss">:chatroom</span><span class="p">,</span> <span class="p">{</span> <span class="ss">:enter</span><span class="p">,</span> <span class="n">name</span> <span class="p">})</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">leave</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="ss">:gen_server</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="ss">:chatroom</span><span class="p">,</span> <span class="p">{</span> <span class="ss">:leave</span><span class="p">,</span> <span class="n">name</span> <span class="p">})</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">message</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="ss">:gen_server</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="ss">:chatroom</span><span class="p">,</span> <span class="p">{</span> <span class="ss">:message</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">message</span> <span class="p">})</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">## Callback implementations&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="nv">@doc</span> <span class="no">false</span>
</span><span class='line'>  <span class="c1"># @doc false stops this showing up in ex_doc, it&amp;rsquo;s a way of hiding</span>
</span><span class='line'>  <span class="c1"># functions from documentation.</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="n">_args</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">{</span> <span class="ss">:ok</span><span class="p">,</span> <span class="no">HashDict</span><span class="o">.</span><span class="n">new</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="nv">@doc</span> <span class="no">false</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">handle_call</span><span class="p">({</span> <span class="ss">:enter</span><span class="p">,</span> <span class="n">name</span> <span class="p">},</span> <span class="n">from</span><span class="p">,</span> <span class="n">users</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2"> has entered the room&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span> <span class="ss">:reply</span><span class="p">,</span> <span class="ss">:ok</span><span class="p">,</span> <span class="no">Dict</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">from</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">handle_call</span><span class="p">({</span> <span class="ss">:leave</span><span class="p">,</span> <span class="n">name</span> <span class="p">},</span> <span class="n">_from</span><span class="p">,</span> <span class="n">users</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">d</span> <span class="o">=</span> <span class="no">Dict</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'><span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2"> has left the room&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span> <span class="ss">:reply</span><span class="p">,</span> <span class="ss">:ok</span><span class="p">,</span> <span class="n">d</span> <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">handle_call</span><span class="p">({</span> <span class="ss">:message</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">message</span> <span class="p">},</span> <span class="n">_from</span><span class="p">,</span> <span class="n">users</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span> <span class="ss">:reply</span><span class="p">,</span> <span class="ss">:ok</span><span class="p">,</span> <span class="n">users</span> <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="c1">## Private functions&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">defp</span> <span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="no">Enum</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="no">Dict</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">users</span><span class="p">),</span> <span class="k">fn</span> <span class="p">{</span> <span class="n">user</span><span class="p">,</span> <span class="n">pid</span> <span class="p">}</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'>  <span class="no">User</span><span class="o">.</span><span class="n">send_line</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Here the messages aren&rsquo;t immediately obvious (unless you&rsquo;re used to OTP) but
they&rsquo;re more explicit. The <code>{ :enter, name }</code>, <code>{ :leave, name }</code> and <code>{
:message, name, message }</code> are the messages, or well, part of them. When you
call <code>:gen_server.call(pid, msg)</code> it actually sends <code>msg</code> inside a wrapper
message that contains information that this is a gen_server call and what the
PID of the sender is. It&rsquo;s all rather complicated stuff intended to make
everything work as it should. Be glad OTP is here to help you, you really don&rsquo;t
want to do this by hand.</p>

<p>Anyway, to get back on the subject, we can see what goes into the messages in
this version. Notice though that the general API hasn&rsquo;t changed. There are still
API functions (the top section) which do nothing but put their arguments in a
message and call <code>:gen_server.send/2</code> to send it.</p>

<p>What has changed however is that where otp_dsl gives you the illusion that
calls are one magic function (<code>defcall enter</code>) here it&rsquo;s clear that there are
two functions: one to send a message to the process and one to handle the
received message. Do note that these run in different processes, the <code>enter</code>
function runs in the process that calls it while <code>handle_call</code> runs in the
chatroom process, I remember it took me a long while before I got used to this
different-functions-in-the-same-module-run-in-different-processes idea when I
was learning Erlang/OTP.</p>

<p>We could send messages from a different process to our chatroom but this is
brittle, if we support this then we can&rsquo;t change the communication protocol
(those <code>{ :enter ...}</code> tuples) because we can&rsquo;t know if some other process is
using them. Having an explicit API simplifies things, other modules and
processes need to know nothing about our code except our API. Sure, if you want
to change the API you&rsquo;re still going to have a bit of a headache, but that&rsquo;s
going to be true of any API in your program and you can apply the same
techniques as everywhere else to compensate for it.</p>

<p>Our modules keep their communication protocol internal to the module. This is
the recommended technique when using OTP. It turns processes into a kind of
active objects (active because they have their own &ldquo;thread&rdquo;), with the external
API defining the methods. In general hiding knowledge about the details of
message passing behind a &ldquo;normal&rdquo; API makes code easier to maintain, which is
why this is a very big thought in Elixir.</p>

<h2>A picture of how a gen_server works</h2>

<p>To needlessly drive the point home I have made a picture which I don&rsquo;t want to
waste, so here it is:</p>

<p><img src="/assets/images/process_interface.svg" alt="Overview of communication to an OTP process" /></p>

<p>This is a picture of a module that implements a gen_server with the usual
external API and internal handles. The blue dots on the outer ring represent API
functions (<code>enter</code> and friends) while the green dots on the inner ring represent
message handlers (<code>handle_call</code>). This picture shows all three types of
communication gen_server supports: calls (to get a reply), casts (fire and
forget, don&rsquo;t wait for a reply) and infos (all other messages). It shows the
generally useful forms of these: calls and casts come from the module itself
while other messages come from outside the module (for example a message with
some data from a socket). Note that there is no law that forbids you from having
two API functions that would trigger the same message handler, this can be quite
handy at times (for example if you have to keep a legacy API function).</p>

<h2>Abstracting the user</h2>

<p>Our chatrooms code sends messages to the user by taking the PIDs that sent the
<code>enter</code> message and passing it to <code>User.send_line</code> (which will presumably send a
message to the user processes that they should pass the line to the user). We
know this is a PID because we got it from the OTP system. In the <code>Chatroom</code>
module we don&rsquo;t <em>need</em> to know this is a PID though, we just need to know it&rsquo;s
something we can pass to <code>User.send_line</code>. We honestly don&rsquo;t care if it&rsquo;s a PID,
some integer, a reference (guaranteed unique value) or something else entirely.</p>

<p>By using the <code>from</code> information from OTP we force a particular pattern: each
user must be a separate process and the user processes must register themselves,
another process can&rsquo;t do that (well, it can, but it&rsquo;s hard and hacky).</p>

<p>There is another way to write <code>enter</code>. Instead of just asking for a name we can
ask for some identifying token and a name. This will work just as well as long
as <code>User.send_line</code> accepts the token. Now it&rsquo;s possible for some other process
to enter a user into a chatroom (not sure if that&rsquo;s ever needed, but it&rsquo;s nice
to have the option). We can also do things like having multiple types of users
each with their own communication protocol and having <code>User.send_line</code> handle
the differences based on information in the token. Again, not something that&rsquo;s
immediately useful, but the flexibility is nice to have.</p>

<p>Note that all it took to add that flexibility is that <code>enter</code> API function,
message and handler got an extra parameter to replace the use of the <code>from</code>
field. Sometimes flexibility is cheap.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir Patterns: Abstract Data Structures]]></title>
    <link href="http://pminten.github.io/blog/2013/09/12/elixir-patterns-abstract-data-structures/"/>
    <updated>2013-09-12T10:45:00+02:00</updated>
    <id>http://pminten.github.io/blog/2013/09/12/elixir-patterns-abstract-data-structures</id>
    <content type="html"><![CDATA[<p>Wouldn&rsquo;t you like to define a data structure as a module, with the internals
hidden? Obviously you can, but because modules are not records the data
structure then can&rsquo;t be used with protocols. You could define a record and in
the <code>do</code> block put functions to manipulate it but then you&rsquo;re making it easy for
your users to use the record directly, and trample on the invariants in the
process.</p>

<h2>Record tags</h2>

<p>Luckily there is a trick. It&rsquo;s not very obvious but if you read the
documentation for <code>Kernel.defrecordp/3</code> closely there is a tag field which is
used in an example to set the tag to the name of the enclosing module. What&rsquo;s
the tag? Well in Erlang, and Elixir, records are stored as tuples with the first
field being a &ldquo;tag&rdquo; that distinguishes different records and the other fields
being the data of the record. With <code>defrecord</code> the tag is always the name of the
record module, with <code>defrecordp</code> it is the record name.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="n">defrecordp</span> <span class="ss">:foo</span><span class="p">,</span> <span class="ss">a:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">b:</span> <span class="no">nil</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="ss">:foo</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="ss">:foo</span><span class="p">,</span> <span class="n">foo</span><span class="p">(</span><span class="ss">a:</span> <span class="m">1</span><span class="p">,</span> <span class="ss">b:</span> <span class="m">2</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="p">{</span> <span class="ss">:foo</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span> <span class="p">}</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">defrecordp</span> <span class="ss">:foo</span><span class="p">,</span> <span class="ss">:bar</span><span class="p">,</span> <span class="ss">a:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">b:</span> <span class="no">nil</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="ss">:foo</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="ss">:bar</span><span class="p">,</span> <span class="n">foo</span><span class="p">(</span><span class="ss">a:</span> <span class="m">1</span><span class="p">,</span> <span class="ss">b:</span> <span class="m">2</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="p">{</span> <span class="ss">:bar</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span> <span class="p">}</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>When defining implementations of protocols the name you pass to <code>for:</code> is the
tag of the record. This makes perfect sense as the protocol doesn&rsquo;t need to know
anything about your record except how to recognize it, and that&rsquo;s what the tag
is for.</p>

<!-- more -->


<h2>An abstract binary tree</h2>

<p>Using record tags you can write an abstract binary tree module like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>An abstract binary tree </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">BinTree</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="c1"># Invariant: left.value &amp;lt;= value &amp;lt;= right.value</span>
</span><span class='line'>  <span class="n">defrecordp</span> <span class="ss">:tree</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="no">MODULE</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span><span class="p">,</span> <span class="ss">value:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">left:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">right:</span> <span class="no">nil</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">new</span><span class="p">()</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">tree</span><span class="p">()</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">from_enum</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="no">Enum</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">|</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">do_from_enum</span><span class="p">()</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">defp</span> <span class="n">do_from_enum</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="n">count</span> <span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="m">0</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="n">middle</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span> <span class="n">left</span><span class="p">,</span> <span class="n">rest</span> <span class="p">}</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">middle</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span> <span class="p">[</span><span class="n">value</span><span class="p">],</span> <span class="n">right</span> <span class="p">}</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
</span><span class='line'>  <span class="n">tree</span><span class="p">(</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">do_from_enum</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="ss">right:</span> <span class="n">do_from_enum</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="no">nil</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">acc</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">[</span><span class="n">value</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="ss">:value</span><span class="p">,</span> <span class="ss">:left</span><span class="p">,</span> <span class="ss">:right</span><span class="p">])</span>
</span><span class='line'><span class="n">acc1</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</span><span class='line'><span class="n">acc2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc1</span><span class="p">)</span>
</span><span class='line'><span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span> <span class="k">do</span>
</span><span class='line'><span class="k">  def</span> <span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="n">_</span><span class="p">,</span> <span class="n">n</span> <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="n">y</span><span class="p">,</span> <span class="n">found</span> <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="o">&gt;</span> <span class="n">found</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">end</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The <code>__MODULE__</code> is a special variable that expands to the name of the module. I
could have written <code>BinTree</code> in it&rsquo;s place, but <code>__MODULE__</code> stands out and is a
good reminder of what trick is used here.</p>

<p>The module works as you&rsquo;d expect:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="no">BinTree</span><span class="o">.</span><span class="n">from_enum</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">4</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="p">{</span><span class="no">BinTree</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="p">{</span><span class="no">BinTree</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="p">{</span><span class="no">BinTree</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="no">nil</span><span class="p">,</span> <span class="no">nil</span><span class="p">},</span> <span class="no">nil</span><span class="p">},</span> <span class="p">{</span><span class="no">BinTree</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="no">nil</span><span class="p">,</span> <span class="no">nil</span><span class="p">}}</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="no">BinTree</span><span class="o">.</span><span class="n">from_enum</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">4</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="m">4</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>We&rsquo;re still showing the guts of the record through <code>inspect</code> though, but that&rsquo;s
easily changed.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defimpl</span> <span class="no">Inspect</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span> <span class="k">do</span>
</span><span class='line'><span class="k">  def</span> <span class="n">inspect</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="c1">#&lt;BinTree #{inspect(Enum.to_list(t))}&gt;&amp;rdquo;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="no">BinTree</span><span class="o">.</span><span class="n">from_enum</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">4</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="c1">#&lt;BinTree [1, 2, 3, 4]&gt;&lt;/h1&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Just remember that we&rsquo;re only hiding the representation when pretty printed, if
you pass <code>raw: true</code> to inspect you&rsquo;ll still see the internal representation.
Due to how Erlang (and thus Elixir) works this is unavoidable, but the pretty
printing serves as a powerful reminder to the user that the internal
representation should not be relied upon.</p>

<h2>Dispatching on the record tag</h2>

<p>There is another trick I&rsquo;d like to show you. If you look at the source of the
<code>Set</code> module from the standard library most functions look like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>A Set function <a href="https://github.com/elixir-lang/elixir/blob/87be134a5b91773643ea292b521c9a8ec8167894/lib/elixir/lib/set.ex#L77-L79">https://github.com/elixir-lang/elixir/blob/87be134a5b91773643ea292b521c9a8ec8167894/lib/elixir/lib/set.ex#L77-L79</a> </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">def</span> <span class="n">difference</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="n">target</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Huh? Object-oriented programming. Nope, just plain old <code>apply/3</code> (if the first
argument is not a literal symbol Elixir translates this to runtime apply call).
The magic is in the <code>target</code> macro:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>target macro <a href="https://github.com/elixir-lang/elixir/blob/87be134a5b91773643ea292b521c9a8ec8167894/lib/elixir/lib/set.ex#L39-L47">https://github.com/elixir-lang/elixir/blob/87be134a5b91773643ea292b521c9a8ec8167894/lib/elixir/lib/set.ex#L39-L47</a> </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmacrop</span> <span class="n">target</span><span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="kn">quote</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="n">is_tuple</span><span class="p">(</span><span class="kn">unquote</span><span class="p">(</span><span class="n">set</span><span class="p">))</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="n">elem</span><span class="p">(</span><span class="kn">unquote</span><span class="p">(</span><span class="n">set</span><span class="p">),</span> <span class="m">0</span><span class="p">)</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">unsupported_set</span><span class="p">(</span><span class="kn">unquote</span><span class="p">(</span><span class="n">set</span><span class="p">))</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Remember that the first field of a record is the tag, so <code>elem(rec, 0)</code> extracts
the record tag. If you call <code>Set.difference(s1, s2)</code> (where <code>s1</code> and <code>s2</code> are
HashSets) <code>target(s1).difference(s1, s2)</code> gets called, which expands to
(ignoring the tuple check) <code>elem(s1, 0).difference(s1, s2)</code>, which effectively
translates to <code>apply(HashSet, :difference, [s1, s2])</code>.</p>

<p>When I first saw that code I spent some time scratching my head over why they
didn&rsquo;t use a protocol. I&rsquo;m still not 100% sure, but I strongly suspect
performance is one of the main reasons. As a test I made a very simple benchmark
to compare the overhead of calling through a protocol vs calling through
<code>apply</code>.</p>

<p><div><script src='https://gist.github.com/2b125e2165713ec49c86.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>

<p>Running this a number of times gives a pretty consistent result after the first
few runs: the protocol calls are about 14-15 times slower than the dispatch
calls (which is how I named the &ldquo;through apply&rdquo; calls, not sure if it&rsquo;s the
right term).</p>

<p>Now protocol calls are known to be slow (that&rsquo;s a big part of why Elixir has
reduce based collections, those only require a few protocol calls even for
large amounts of data). There are
<a href="https://github.com/elixir-lang/elixir/issues/950">ideas</a> on how to fix that and
once those get implemented things may change for released code. For now however
indirect calls through <code>apply</code> are significantly faster.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Set&rsquo;s callbacks <a href="https://github.com/elixir-lang/elixir/blob/87be134a5b91773643ea292b521c9a8ec8167894/lib/elixir/lib/set.ex#L20-L37">https://github.com/elixir-lang/elixir/blob/87be134a5b91773643ea292b521c9a8ec8167894/lib/elixir/lib/set.ex#L20-L37</a> </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="kn">use</span> <span class="no">Behaviour</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="nv">@type</span> <span class="n">value</span> <span class="p">::</span> <span class="n">any</span>
</span><span class='line'><span class="nv">@type</span> <span class="n">values</span> <span class="p">::</span> <span class="p">[</span> <span class="n">value</span> <span class="p">]</span>
</span><span class='line'><span class="nv">@type</span> <span class="n">t</span> <span class="p">::</span> <span class="n">tuple</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">defcallback</span> <span class="n">delete</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">difference</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">disjoint?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">boolean</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">empty</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">equal?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">boolean</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">intersection</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">member?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">::</span> <span class="n">boolean</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">put</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">size</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">non_neg_integer</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">subset?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">boolean</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">to_list</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">list</span><span class="p">()</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">union</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>If you look at <code>Set</code> again notice that it&rsquo;s a behaviour with callbacks of the
same types and arity for each exposed function. All the implementation modules
(just <code>HashSet</code> in the standard library) implement the <code>Set</code> behaviour and the
compiler makes sure that all the functions are indeed implemented. If you&rsquo;re
going to do the same protocol replacing trick as <code>Set</code> it&rsquo;s a good idea to
define a behaviour as well.</p>

<h2>Caveats</h2>

<p>So what are the downsides of the abstract data structure technique? Well you
lose the nice record syntax and decomposition and have to work with the macros
<code>defrecordp</code> generates for you. And it&rsquo;s a bit more work getting everything set
up.</p>

<p>But let&rsquo;s face it, those are minor issues. What you get is the ability to
offer a data structure without exposing it&rsquo;s representation. You get the ability
to make a data structure that (ugly hacks aside) can only be manipulated through
the API you provide, an API that maintains the internal invariants.</p>

<p>If you define a public record stop and think for a moment why you are defining
the record that way, because often hiding it in a module results in cleaner,
more maintainable code.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir Patterns: Mixins]]></title>
    <link href="http://pminten.github.io/blog/2013/09/11/elixir-patterns-mixins/"/>
    <updated>2013-09-11T13:48:00+02:00</updated>
    <id>http://pminten.github.io/blog/2013/09/11/elixir-patterns-mixins</id>
    <content type="html"><![CDATA[<p>Elixir&rsquo;s macros are a powerful way to add language features without encoding
them in the language core itself. One of such features is a pattern one could
call &ldquo;mixin&rdquo; (by analogy to the
<a href="https://en.wikipedia.org/wiki/Mixin">Mixin concept</a> in class based
object-oriented languages.</p>

<p>In Ruby mixin modules are used for example to define the <code>==</code>, <code>&lt;</code>, <code>&gt;=</code>, etc
operators for a class if the <code>&lt;=&gt;</code> (compare) operator is defined. The compare
operator returns -1 if the first argument is smaller than the second, 0
if it is equal to the second and 1 if it is greater than the second. Obviously
if you have that it&rsquo;s easy to define <code>&lt;</code> and friends. By including the
<code>Comparable</code> mixin you get most of the comparison operators for free, just
remember to define <code>&lt;=&gt;</code>.</p>

<h2>Default functions for protocols</h2>

<p>In Elixir we don&rsquo;t have classes but we do have similar situations where you
generally want to define something in terms of something else. Take for example
<code>Enumerable</code>. The <code>Enumerable</code> protocol has three methods: <code>reduce/3</code>, <code>count/1</code>
and <code>member?/2</code>. However you can always define <code>count</code> and <code>member?</code> in
terms of <code>reduce</code>, they&rsquo;re just there so that you can override them with a more
efficient implementation.</p>

<p>Because protocols don&rsquo;t support default definitions for a method you always have
to define all three, even if you don&rsquo;t do anything special for <code>count</code> and
<code>member?</code>. That is to say for a simple binary tree you have to write:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">defrecord</span> <span class="no">BinTree</span><span class="p">,</span> <span class="ss">value:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">left:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">right:</span> <span class="no">nil</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span> <span class="k">do</span>
<span class="k">  def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">acc</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">acc1</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
<span class="n">acc2</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc1</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
<span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">count</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="k">end</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></p>

<p>Using a mixin we can simplify this. A mixin in Elixir is generally defined as a
module with a <code>__using__</code> macro.</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">Enumerable</span><span class="o">.</span><span class="no">Mixin</span> <span class="k">do</span>
<span class="k">  defmacro</span> <span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">using</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kn">quote</span> <span class="ss">location:</span> <span class="n">keep</span> <span class="k">do</span>
<span class="k">  def</span> <span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></p>

<!-- more -->


<p>By simply writing <code>use Enumerable.Mixin</code> we now get <code>count</code> and <code>member?</code>
defined in our module. The argument to <code>__using__</code> we&rsquo;re ignoring is a list of
keywords that you can use with <code>use</code>, for example <code>use ExUnit.TestCase, async:
true</code>.</p>

<p>With the mixin our code becomes simpler:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span> <span class="k">do</span>
<span class="k">  </span><span class="kn">use</span> <span class="no">Enumerable</span><span class="o">.</span><span class="no">Mixin</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">acc</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">acc1</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
<span class="n">acc2</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc1</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
<span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></p>

<p>Certainly an improvement. But what if we want to define one of the methods we
generated. For example if our binary tree has the invariant &ldquo;left.value &lt; value
&lt; right.value&rdquo; we can use that for faster member testing.</p>

<p>To support this we&rsquo;ll mark the mixed in functions as overridable. That means
that if the compiler comes across a new definition for the function (i.e.
function clauses that aren&rsquo;t right next to previous clauses of the function) it
will not complain but forget about the old definition of the function and use
the new one.</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">Enumerable</span><span class="o">.</span><span class="no">Mixin</span> <span class="k">do</span>
<span class="k">  defmacro</span> <span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">using</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kn">quote</span> <span class="ss">location:</span> <span class="n">keep</span> <span class="k">do</span>
<span class="k">  def</span> <span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">defoverridable</span> <span class="p">[</span><span class="ss">count:</span> <span class="m">1</span><span class="p">,</span> <span class="ss">member?:</span> <span class="m">2</span><span class="p">]</span>
<span class="k">end</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></p>

<p>The arguments to <code>defoverridable</code> are the function names and arities of the
functions you want to be overridable. Now that <code>member?</code> is overridable we can
define a new custom <code>member?</code>:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span> <span class="k">do</span>
<span class="k">  </span><span class="kn">use</span> <span class="no">Enumerable</span><span class="o">.</span><span class="no">Mixin</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">acc</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">acc1</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
<span class="n">acc2</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc1</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
<span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">false</span>
  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">cond</span> <span class="k">do</span>
<span class="k">  </span><span class="n">x</span> <span class="o">==</span> <span class="n">value</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="no">true</span>
  <span class="n">x</span> <span class="err">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">value</span>  <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">member?</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span> <span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">value</span>  <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">member?</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="k">end</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></p>

<p>Now our <code>member?</code> is much faster, assuming a balanced tree of 1024 nodes it only
takes 10 steps instead of 1024 steps.</p>

<h2>Behaviours</h2>

<p>Another place where mixins come in handy is in OTP style behaviours. Take a look
at a (slightly edited) bit of GenServer.Behaviour:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">GenServer</span><span class="o">.</span><span class="no">Behaviour</span>
  <span class="k">defmacro</span> <span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">using</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kn">quote</span> <span class="ss">location:</span> <span class="ss">:keep</span> <span class="k">do</span>
<span class="k">  </span><span class="nv">@behavior</span> <span class="ss">:gen_server</span>

  <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="p">{</span> <span class="ss">:ok</span><span class="p">,</span> <span class="n">args</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">handle_call</span><span class="p">(</span><span class="n">_request</span><span class="p">,</span> <span class="n">_from</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="p">{</span> <span class="ss">:noreply</span><span class="p">,</span> <span class="n">state</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="c1"># functions ommitted</span>

  <span class="n">defoverridable</span> <span class="p">[</span><span class="ss">init:</span> <span class="m">1</span><span class="p">,</span> <span class="ss">handle_call:</span> <span class="m">3</span><span class="p">,</span> <span class="ss">handle_info:</span> <span class="m">2</span><span class="p">,</span>
    <span class="ss">handle_cast:</span> <span class="m">2</span><span class="p">,</span> <span class="ss">terminate:</span> <span class="m">2</span><span class="p">,</span> <span class="ss">code_change:</span> <span class="m">3</span><span class="p">]</span>
<span class="k">end</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></p>

<p>This declares the module that uses <code>GenServer.Behaviour</code> to be a gen_server
callback module (<code>@behavior :gen_server</code>) and declares all the callbacks with
simple no-op implementations, which are overridable. The idea is that you define
just the callbacks you need without being forced to declare all of them just to
keep the compiler happy.</p>

<h2>Caveats</h2>

<p>Mixins are a great tool. But like all tools they have their specific strengths
and weaknesses. Ever tried to put a nail in a wall with a screw driver?</p>

<p>Mixins are macro&rsquo;s and as such they tend to obscure the true meaning of the
code. If you refer to a function that was introduced by a mixin people might
wonder where that function came from. Luckily <code>use</code> is fairly easy to spot so
this isn&rsquo;t such a big problem.</p>

<p>Mixins also bloat the code by placing copies of definitions in multiple files.
It&rsquo;s best to keep mixed in definitions simple, if you need something more
complicated consider factoring out the part of a function that doesn&rsquo;t need to
be in the target module into a separate function in some common module and call
that.</p>

<p>Finally badly documented mixins make understanding what goes on in the target
module much harder than it needs to be. If you write a mixin make sure you
include documentation on what functions it adds and what they do.</p>

<p>These small quibbles aside mixins are a great tool for reducing the amount of
boilerplate in modules.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elixir's Enumerable]]></title>
    <link href="http://pminten.github.io/blog/2013/09/05/elixirs-enumerable/"/>
    <updated>2013-09-05T00:00:00+02:00</updated>
    <id>http://pminten.github.io/blog/2013/09/05/elixirs-enumerable</id>
    <content type="html"><![CDATA[<p>Sometimes Elixir can be quite a pain. Often it&rsquo;s because the libraries don&rsquo;t yet
have what you need or because a feature that looks like it&rsquo;s going to do exactly
what you want turns out to be more limited than you would like (<code>|&gt;</code> I&rsquo;m looking
at you). Sometimes however the pain is of a different kind, the kind you get
from trying to understand why that seemingly logical Go move is the exact
opposite of what&rsquo;s good, the kind you get from reading about category theory,
the kind you get from trying to use the newest kind of lenses in Haskell. In
other words the kind of pain that comes from desperately trying to understand
something that seems to make no sense at all.</p>

<p>And then, after beating your head against the proverbial desk enough time, you
suddenly realize that things are starting to make sense and that it&rsquo;s actually
all quite clear.</p>

<p>Today I had one of those moments. After trying to produce a better stream design
based on functions that return a value and a replacement for themselves (think
Continuation Passing Style) I ran into a problem where my <code>Iter.to_list</code> was
much slower than <code>Enum.to_list</code>. When I asked on IRC @ericmj told me that it&rsquo;s
just not possible to make my iterator approach work fast enough and that that&rsquo;s
the reason Elixir switched to a reduce based approach. He also gave me the
excellent tip to look at Clojure&rsquo;s <a href="http://clojure.org/reducers">reducers</a>,
which was the inspiration for Elixir&rsquo;s design.</p>

<p>While the blog posts linked from Clojure&rsquo;s documentation are informative they
are (naturally) about Clojure and not everybody understands that. So here&rsquo;s an
attempt to explain things in an Elixir context.</p>

<!-- more -->


<p>This post consists of four main parts.</p>

<ul>
<li><a href="#uses">A bit about what <code>Enumerable</code>, <code>Enum</code> and <code>Stream</code> are useful for.</a></li>
<li><a href="#enum">An explanation of how <code>Enum</code> is implemented in terms of <code>Enumerable</code>.</a></li>
<li><a href="#reduce">A short dicussion on writing your own <code>reduce</code> function.</a></li>
<li><a href="#stream">An explanation of how streams are used to efficiently compose
enumerables.</a></li>
</ul>


<h2>Enumerable, Enum and Stream <a name="uses">&nbsp;</a></h2>

<p>As the user of Elixir code you will often use <code>Enum</code>, sometimes use <code>Stream</code> and
rarely implement <code>Enumerable</code>. The
<a href="http://elixir-lang.org/docs/stable/Enum.html"><code>Enum</code></a> module is where most of
Elixir&rsquo;s collection manipulation code resides. It has your basic <code>map/2</code>,
<code>filter/2</code> and <code>reduce/3</code> functions as well as stuff like <code>at/2</code> / <code>fetch/2</code>
(look up an element given an index), <code>drop/2</code> and <code>min/1</code>. Whenever you want to
do something with a collection look in <code>Enum</code> first. Often the tools you need
are there.</p>

<p>Sometimes the methods from <code>Enum</code> are somewhat inefficient. Take for example
tripling some numbers and filtering out multiples of 7 afterwards
(<code>Enum.filter_map</code> doesn&rsquo;t help here, it filters before mapping). You could
write <code>Enum.map(l, &amp;(&amp;1 * 3)) |&gt; Enum.filter(&amp;(rem(&amp;1, 7) != 0))</code> but there&rsquo;s an
inefficiency. It comes from <code>Enum.map</code> constructing a list which is immediately
&ldquo;eaten&rdquo; by <code>Enum.filter</code>.  This work is unnecessary if <code>Enum.map</code> could somehow
pass elements to <code>Enum.filter</code> one by one.</p>

<p>This is where streams come in. By simply writing <code>Stream.map(l, &amp;(&amp;1 * 3)) |&gt;
Enum.filter(&amp;(rem(&amp;1, 7) != 0))</code> the inefficiency is removed. Instead of
returning a list <code>Stream.map/2</code> returns a stream for which there is an
<code>Enumerable</code> implementation so it can be used with <code>Enum</code>. Now what <code>Stream.map</code>
does is it creates a stream that wraps an enumerable and whenever an element is
requested it fetches the element from the enumerable but before passing it along
transforms it using the function given to <code>Stream.map</code>.</p>

<p>Because all the <code>Stream</code> functions return streams sooner or later you&rsquo;ll need to
use <code>Enum</code> functions to get a list or some other value (such as a sum) out of
the stream.</p>

<p>It&rsquo;s actually pretty easy to make your own data structures work with <code>Enum</code> and
<code>Stream</code>. For that you need to define your data structure as a record and add an
<code>Enumerable</code> implementation for it.</p>

<h2>Reduce and Enum <a name="enum">&nbsp;</a></h2>

<p>The <code>reduce</code> function, also known as (left) fold in other languages, is the most
direct translation of loops like this:</p>

<p><div class="highlight"><pre><code class="ruby"><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span> <span class="k">do</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">i</span>
<span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>

<span class="sr">&lt;h1&gt;a is now 3628800&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>
</code></pre></div></p>

<p>In Elixir we would write such a loop using <code>Enum.reduce/3</code> as:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">10</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">acc</span> <span class="o">*</span> <span class="n">i</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">end</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">returns</span> <span class="m">3628800</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre></div></p>

<p>Simple enough, isn&rsquo;t it. There&rsquo;s nothing complicated about reduce, well not
until you look at the implementation of streams.</p>

<p>Reducing works by walking down a data structure (typically a list) and to call a
function for each element. The function gets passed the element from the list
and a state value (called an accumulator) and is expected to return a new state
value, which gets passed to the function the next time it&rsquo;s called.  The initial
state value is what you pass to <code>reduce</code> as the second argument. From now on I
will refer to state values as accumulators.</p>

<p>All functions in <code>Enum</code> are conceptually based on this simple function (more on
that later). For example <code>map/2</code> can be very efficiently expressed using a reduce.
Here&rsquo;s the typical code for map:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">map</span><span class="p">([],</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="p">[]</span>
<span class="k">def</span> <span class="n">map</span><span class="p">([</span><span class="n">h</span><span class="o">|</span><span class="n">t</span><span class="p">],</span> <span class="n">f</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">|</span><span class="n">t</span><span class="p">]</span>
</code></pre></div></p>

<p>Err, wait a minute. That can&rsquo;t be right. This function isn&rsquo;t tail recursive and
will thus eat much more stack memory than it needs to. This is more realistic:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">map</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_map</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">[])</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">defp</span> <span class="n">do_map</span><span class="p">([],</span> <span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="ss">:lists</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
<span class="k">defp</span> <span class="n">do_map</span><span class="p">([</span><span class="n">h</span><span class="o">|</span><span class="n">t</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_map</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">|</span><span class="n">acc</span><span class="p">])</span>
</code></pre></div></p>

<p>I&rsquo;ve used <code>:lists.reverse</code> to avoid depending on <code>Enum</code> as the point of this
example is how you could do things without <code>Enum</code>. It&rsquo;s also slightly faster (no
overhead from calling a protocol function) and the fact that it&rsquo;s restricted to
lists doesn&rsquo;t matter as we&rsquo;re working on lists anyway.</p>

<p>Now here&rsquo;s how you would write <code>map/2</code> using <code>Enumerable</code>, so it works for every
enumerable:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">map</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Enumerable</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[],</span> <span class="k">fn</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span><span class="n">acc</span><span class="p">]</span> <span class="k">end</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="ss">:lists</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div></p>

<p>While superficially different this is actually a lot like the accumulator
version of map with a few differences. Firstly the recursive call to <code>do_map</code> is
gone, instead just the new accumulator is returned. Secondly there&rsquo;s no more
manual pattern matching to get the first element of the list. Instead the
<code>Enumerable.reduce</code> function passes our function an element, one at a time.</p>

<p>Read that last sentence again, it&rsquo;s key to understanding the power of reduce.
The <code>reduce</code> function is responsible for calling the function we supply with
each element. It is responsible for the how of iteration. Our function doesn&rsquo;t
need to know anything about the data structure we&rsquo;re iterating over as long as
there&rsquo;s a function that can call our function. Don&rsquo;t call us, we&rsquo;ll call you.</p>

<p>Another important function in <code>Enum</code> is <code>filter/2</code>. Again the translation is
quite obvious:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">filter</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_filter</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">[])</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">defp</span> <span class="n">do_filter</span><span class="p">([],</span> <span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="ss">:lists</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
<span class="k">defp</span> <span class="n">do_filter</span><span class="p">([</span><span class="n">h</span><span class="o">|</span><span class="n">t</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  if</span> <span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">do_filter</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">h</span><span class="o">|</span><span class="n">acc</span><span class="p">])</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">else</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">do_filter</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">acc</span><span class="p">])</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">filter</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Enumerable</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[],</span> <span class="k">fn</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span><span class="n">acc</span><span class="p">]</span>
<span class="k">else</span>
  <span class="n">acc</span>
<span class="k">end</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="ss">:lists</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div></p>

<p>Just the same transformation as for map.</p>

<p>A function like <code>count/1</code> can be implemented as:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Enumerable</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="o">&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></p>

<p>In reality it&rsquo;s a call to <code>Enumerable.count/1</code>, one of the two extra
(non-reduce) functions on <code>Enumerable</code> (the other is <code>member?/2</code>) which are
probably there to support data structures that have a faster way of computing
them than using <code>reduce</code> (like sets). We&rsquo;ll talk a look at creating an
<code>Enumerable</code> implementation for a custom data structure in the next section.</p>

<p>As you have seen all the <code>Enum</code> functions can be easily and efficiently
implemented using <code>reduce</code>. <code>reduce</code> is quite general. It&rsquo;s also not all that
hard to implement, as we shall see.</p>

<h2>Writing a reduce function <a name="reduce">&nbsp;</a></h2>

<p>We&rsquo;ve seen how you can use <code>reduce/3</code> to do quite a lot of things. But how do
you create a reduce function? Let&rsquo;s look at a few examples. First, a data
structure (a binary tree).</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">BinTree</span> <span class="k">do</span>
<span class="k">  defrecord</span> <span class="no">Tree</span><span class="p">,</span> <span class="ss">value:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">left:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">right:</span> <span class="no">nil</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">acc</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">Tree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">acc1</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
<span class="n">acc2</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc1</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
<span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></p>

<p>To reduce a binary tree we&rsquo;ll first give the value to the passed reducer
function and then call reduce on the left and right trees. Now that we have
<code>reduce</code> it&rsquo;s easy to define an <code>Enumerable</code> implementation:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span> <span class="k">do</span>
<span class="k">  def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
  <span class="k">def</span> <span class="n">count</span><span class="p">(</span><span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="k">end</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></p>

<p>The <code>count/1</code> and <code>member?/2</code> functions are required as part of the <code>Enumerable</code>
protocol, but you can always define them like I did. They&rsquo;re mostly useful for
when you have a faster way to compute them. For example if the tree has a
guarantee that left.value &lt; value &lt; right.value you could use that to avoid
examining the whole tree.</p>

<p>Let&rsquo;s test it:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="n">t</span> <span class="o">=</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[</span><span class="ss">value:</span> <span class="m">1</span><span class="p">,</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>             <span class="ss">left:</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[</span><span class="ss">value:</span> <span class="m">2</span><span class="p">],</span>
             <span class="ss">right:</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[</span><span class="ss">value:</span> <span class="m">3</span><span class="p">]]</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="no">Enum</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>    <span class="c1"># returns [1, 2, 3]</span>
<span class="no">Enum</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>      <span class="c1"># returns 3</span>
<span class="no">Enum</span><span class="o">.</span><span class="n">member?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c1"># returns true</span>
<span class="no">Enum</span><span class="o">.</span><span class="n">member?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span> <span class="c1"># returns false</span>
</code></pre></div></p>

<p>Ok, time for a more complicated scenario, which I&rsquo;ll also revisit in the
section about streams to demonstrate how enumerable can be used to create very
effective pipelines. Let&rsquo;s say you have a very big file and want to read it in
blocks of 512 bytes. There&rsquo;s stuff for this in the standard library
(<code>File.stream!/2</code>, <code>IO.binstream/2</code> and more). But for the sake of learning
let&rsquo;s pretend all that isn&rsquo;t there.</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">BlockReader</span> <span class="k">do</span>
<span class="k">  defexception</span> <span class="no">ReadError</span><span class="p">,</span> <span class="ss">message:</span> <span class="no">nil</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">def</span> <span class="n">read!</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">block_size</span> <span class="o">//</span> <span class="m">512</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">fn</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">do_read!</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">end</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">defp</span> <span class="n">do_read!</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">case</span> <span class="no">IO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">block_size</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="ss">:eof</span>                      <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">acc</span>
  <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">reason</span><span class="p">}</span>          <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="k">raise</span> <span class="no">ReadError</span><span class="p">,</span> <span class="ss">message:</span> <span class="n">reason</span>
  <span class="n">data</span> <span class="ow">when</span> <span class="n">is_binary</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">do_read!</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span> <span class="n">fun</span><span class="p">)</span>
<span class="k">end</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></p>

<p>Given an open file (i.e. an IO device) this will cut up a file in blocks.  It
can be used like this:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="no">File</span><span class="o">.</span><span class="n">open!</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">some_file</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;)</span> <span class="o">|&gt;</span> <span class="no">BlockReader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
</code></pre></div></p>

<p>Quick question to see whether you&rsquo;ve been paying attention, did you notice that
<code>BlockReader.read!</code> works a bit differently than <code>BinTree.reduce</code>?</p>

<p>While <code>BinTree.reduce</code> calls the supplied function directly <code>BlockReader.read!</code>
returns a function that takes an accumulator and a reducer function. So how does
this work? Well <code>Enumerable</code> is implemented for functions. Any function that
takes two arguments, initial accumulator and function is a valid <code>Enumerable</code>.
The <code>reduce</code> implementation for functions very simple:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">function</span><span class="o">.</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div></p>

<p>In other words when a function gets passed to <code>Enum.reduce</code> all that happens is
that the function gets called with the other two arguments of <code>Enum.reduce</code>
(namely the accumulator and reducer function).</p>

<p>Besides manually writing reduce functions there are also a few functions in
<code>Stream</code> that generate them such as <code>Stream.iterate/2</code> and
<code>Stream.repeatedly/1</code>.</p>

<p>In the next section we&rsquo;ll see how streams allow us to put something between a
reduction function and the reducer.</p>

<h2>Streaming transformations <a name="stream">&nbsp;</a></h2>

<p>It&rsquo;s easy enough to write some code that computes the line count and character
count (grapheme count to be precise) of each line of a file:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="no">File</span><span class="o">.</span><span class="n">stream!</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">my_file</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;)</span> <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">({</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">},</span> <span class="k">fn</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">{</span><span class="n">lines</span><span class="p">,</span> <span class="n">chars</span><span class="p">})</span> <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="o">&gt;</span>
  <span class="p">{</span><span class="n">lines</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">chars</span> <span class="o">+</span> <span class="no">String</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">line</span><span class="p">)}</span>
<span class="k">end</span><span class="p">)</span>
</code></pre></div></p>

<p>But what if we want something a little more complicated, like, say, ignoring
lines that start with &lsquo;#&rsquo;? We could of course complicate the reducer function
but there&rsquo;s an alterative.</p>

<p>Streams allow us to stick something (like a map or a filter) in the middle of a
reduction pipeline.</p>

<p><div class="highlight"><pre><code class="elixir"><span class="no">File</span><span class="o">.</span><span class="n">stream!</span><span class="p">(</span><span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">my_file</span><span class="err">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
  <span class="o">|&gt;</span> <span class="no">Stream</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="err">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="no">String</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="err">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="m">1</span><span class="p">,</span> <span class="err">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="c1">#&amp;rdquo;)))</span>
  <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">({</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">},</span> <span class="k">fn</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">{</span><span class="n">lines</span><span class="p">,</span> <span class="n">chars</span><span class="p">})</span> <span class="err">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>   <span class="p">{</span><span class="n">lines</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">chars</span> <span class="o">+</span> <span class="no">String</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">line</span><span class="p">)}</span>
 <span class="k">end</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre></div></p>

<p>Here <code>Stream.reject/2</code> (reject is filter with the condition inverted) very
efficiently filters out the lines we don&rsquo;t want, without constructing a big
intermediate list of course.</p>

<p>Streams are easy to use, you just stick them between a generator (like
<code>File.stream!</code>) and some call to an <code>Enum</code> function.</p>

<p>Most, if not all, of the time the functions in <code>Stream</code> are all you need to work
with streams. But it&rsquo;s good to know how they work under the hood. Well, it&rsquo;s a
little bit complicated I&rsquo;m afraid.</p>

<p>Let&rsquo;s start by looking at the <code>Stream.Lazy</code> record:</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">defrecord</span> <span class="no">Stream</span><span class="o">.</span><span class="no">Lazy</span><span class="p">,</span> <span class="ss">enumerable:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">fun:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">acc:</span> <span class="no">nil</span>
</code></pre></div></p>

<p>Three fields: <code>enumerable</code>, <code>fun</code> and <code>acc</code>. The <code>enumerable</code> field is due to a
pipeline <code>File.stream!("a") |&gt; Stream.map(&amp;some_fun/1) |&gt; Enum.each(&amp;IO.puts/1)</code>
being translated (by the <code>|&gt;</code> macro) to <code>Enum.each(Stream.map(File.stream!("a"),
&amp;some_fun/1), &amp;IO.puts/1)</code>, meaning that <code>Stream.map</code> wraps the result of
<code>File.stream!</code> (which is a reducer calling function, which is an enumerable,
like in our implementation). The <code>enumerable</code> field stores the enumerable passed
to <code>Stream.map</code>.</p>

<p>The <code>acc</code> field stores the accumulator for your stream. It can be <code>nil</code>, if you
don&rsquo;t have an accumulator. The <code>fun</code> field stores your stream function.</p>

<p>The stream function should always accept a reducer function (I&rsquo;ll call
this the &ldquo;inner&rdquo; reducer). If you&rsquo;re using an accumulator (the <code>acc</code> field is
specified and not <code>nil</code>) it should also accept and something commonly called
<code>nesting</code> that you only need if you want to stop streaming before the input is
done (more on that later). So a non-accumulator-using stream function should
accept an inner reducer and an accumulator-using stream function should accept
an inner reducer and <code>_nesting</code>.  If you consider this to be confusing, I fully
agree.</p>

<p>The stream function should return another function. If you&rsquo;re using an
accumulator the function should accept an entry (from the &ldquo;outer&rdquo;
generator/stream, so the input you&rsquo;re working on) and an accumulator for the
inner reducer function and return a new accumulator for it. For example here&rsquo;s
how you could implement a stream that adds 1 to each input before passing it
along.</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">add_one</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Stream</span><span class="o">.</span><span class="no">Lazy</span><span class="p">[</span><span class="ss">enumerable:</span> <span class="n">e</span><span class="p">,</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>          <span class="c1"># acc is nil by default</span>
          <span class="ss">fun:</span> <span class="k">fn</span><span class="p">(</span><span class="n">inner_fun</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span>
            <span class="k">fn</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inner_acc</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">inner_fun</span><span class="o">.</span><span class="p">(</span><span class="n">entry</span> <span class="o">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">inner_acc</span><span class="p">)</span> <span class="k">end</span>
          <span class="k">end</span><span class="p">]</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">end</span>
</code></pre></div></p>

<p>If the accumulator is not <code>nil</code> you get a tuple <code>{ inner_acc, my_acc }</code> instead
of just <code>inner_acc</code> and should return a similar tuple. Take for example a
function that adds successive numbers to each value.</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">add_increasing</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Stream</span><span class="o">.</span><span class="no">Lazy</span><span class="p">[</span><span class="ss">enumerable:</span> <span class="n">e</span><span class="p">,</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>          <span class="ss">acc:</span> <span class="m">1</span><span class="p">,</span>
          <span class="ss">fun:</span> <span class="k">fn</span><span class="p">(</span><span class="n">inner_fun</span><span class="p">,</span> <span class="n">_nesting</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span>
            <span class="k">fn</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="p">{</span> <span class="n">inner_acc</span><span class="p">,</span> <span class="n">my_acc</span> <span class="p">})</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span> 
              <span class="p">{</span> <span class="n">inner_fun</span><span class="o">.</span><span class="p">(</span><span class="n">entry</span> <span class="o">+</span> <span class="n">my_acc</span><span class="p">,</span> <span class="n">inner_acc</span><span class="p">),</span> <span class="n">my_acc</span> <span class="o">+</span> <span class="m">1</span> <span class="p">}</span>
            <span class="k">end</span>
          <span class="k">end</span><span class="p">]</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">end</span>
</code></pre></div></p>

<p>That&rsquo;s most of the magic of stream functions. One tiny detail remains. Remember
that weird <code>nesting</code> argument? It&rsquo;s used when you want to early abort a stream
(before the input is done). This is used in <code>Stream.take</code> and it depends on
throwing a tuple. Please don&rsquo;t write code that uses this, consider the internal
throw an implementation detail that&rsquo;s not supposed to leak. I&rsquo;m only showing it
to explain how <code>Stream</code> works internally.</p>

<p><div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">until_second_boom</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Stream</span><span class="o">.</span><span class="no">Lazy</span><span class="p">[</span><span class="ss">enumerable:</span> <span class="n">e</span><span class="p">,</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="err">&gt;</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>          <span class="ss">acc:</span> <span class="m">1</span><span class="p">,</span>
          <span class="ss">fun:</span> <span class="k">fn</span><span class="p">(</span><span class="n">inner_fun</span><span class="p">,</span> <span class="n">nesting</span><span class="p">)</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span>
            <span class="k">fn</span>
              <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="p">{</span> <span class="n">inner_acc</span><span class="p">,</span> <span class="m">0</span> <span class="p">})</span> <span class="ow">when</span> <span class="n">entry</span> <span class="o">==</span> <span class="s2">&quot;boom&quot;</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span>
                <span class="k">throw</span> <span class="p">{</span> <span class="ss">:stream_lazy</span><span class="p">,</span> <span class="n">nesting</span><span class="p">,</span> <span class="n">inner_acc</span> <span class="p">}</span>
              <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="p">{</span> <span class="n">inner_acc</span><span class="p">,</span> <span class="n">my_acc</span> <span class="p">})</span> <span class="o">-</span><span class="err">&amp;</span><span class="n">gt</span><span class="p">;</span>
                <span class="p">{</span> <span class="n">inner_fun</span><span class="o">.</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inner_acc</span><span class="p">),</span>
                  <span class="p">(</span><span class="k">if</span> <span class="n">entry</span> <span class="o">==</span> <span class="s2">&quot;boom&quot;</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="n">my_acc</span> <span class="o">-</span> <span class="m">1</span><span class="p">,</span> <span class="k">else</span><span class="p">:</span> <span class="n">my_acc</span><span class="p">)</span> <span class="p">}</span>
            <span class="k">end</span>
          <span class="k">end</span><span class="p">]</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="err">&gt;</span><span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">end</span>
</code></pre></div></p>

<p>When you run this code with <code>MyMod.until_second_boom([1,2,"boom",3,"boom"]) |&gt;
Enum.to_list</code> the result is <code>[1,2,"boom",3]</code>.</p>

<p>That&rsquo;s it for <code>Stream</code>. Please note however that you&rsquo;re not supposed to write
your own streams. If you need something that&rsquo;s missing from <code>Stream</code> please
write a patch for it. That way you won&rsquo;t run the risk of something breaking if
the implementation of <code>Stream</code> is updated.</p>

<h2>Wrapping it up</h2>

<p>We&rsquo;ve seen how <code>Enumerable</code> lets you work with all kinds of data structures and
custom stream sources (<code>File.stream!</code>) through a consistent interface. With
<code>Enum</code> and <code>Stream</code> pipelines of transformations can be both expressive and
efficient.  Yet at the same time there&rsquo;s great flexibility, you can define your
own stream sources and your own stream &ldquo;consumers&rdquo;. You can even (but are not
advised to) define your own stream functions.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
