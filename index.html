
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>A Cauldron of Black and White Stones</title>
  <meta name="author" content="Peter Minten">

  
  <meta name="description" content="Wouldn&rsquo;t you like to define a data structure as a module, with the internals
hidden? Obviously you can, but because modules are not records the &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://pminten.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="A Cauldron of Black and White Stones" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">A Cauldron of Black and White Stones</a></h1>
  
    <h2>Peter Minten's blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://www.duckduckgo.com/" method="get">
  <fieldset role="search">
    <input type="hidden" name="sites" value="duckduckgo.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search&hellip;"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/12/elixir-patterns-abstract-data-structures/">Elixir Patterns: Abstract Data Structures</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-12T10:45:00+02:00" pubdate data-updated="true">Sep 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Wouldn&rsquo;t you like to define a data structure as a module, with the internals
hidden? Obviously you can, but because modules are not records the data
structure then can&rsquo;t be used with protocols. You could define a record and in
the <code>do</code> block put functions to manipulate it but then you&rsquo;re making it easy for
your users to use the record directly, and trample on the invariants in the
process.</p>

<h2>Record tags</h2>

<p>Luckily there is a trick. It&rsquo;s not very obvious but if you read the
documentation for <code>Kernel.defrecordp/3</code> closely there is a tag field which is
used in an example to set the tag to the name of the enclosing module. What&rsquo;s
the tag? Well in Erlang, and Elixir, records are stored as tuples with the first
field being a &ldquo;tag&rdquo; that distinguishes different records and the other fields
being the data of the record. With <code>defrecord</code> the tag is always the name of the
record module, with <code>defrecordp</code> it is the record name.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="n">defrecordp</span> <span class="ss">:foo</span><span class="p">,</span> <span class="ss">a:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">b:</span> <span class="no">nil</span>
</span><span class='line'><span class="c1"># name = :foo, tag = :foo, foo(a: 1, b: 2) ==&gt; { :foo, 1, 2 }</span>
</span><span class='line'><span class="n">defrecordp</span> <span class="ss">:foo</span><span class="p">,</span> <span class="ss">:bar</span><span class="p">,</span> <span class="ss">a:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">b:</span> <span class="no">nil</span>
</span><span class='line'><span class="c1"># name = :foo, tag = :bar, foo(a: 1, b: 2) ==&gt; { :bar, 1, 2 }</span>
</span></code></pre></td></tr></table></div></figure>


<p>When defining implementations of protocols the name you pass to <code>for:</code> is the
tag of the record. This makes perfect sense as the protocol doesn&rsquo;t need to know
anything about your record except how to recognize it, and that&rsquo;s what the tag
is for.</p>

<h2>An abstract binary tree</h2>

<p>Using record tags you can write an abstract binary tree module like this:</p>

<figure class='code'><figcaption><span>An abstract binary tree </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">BinTree</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="c1"># Invariant: left.value &lt;= value &lt;= right.value</span>
</span><span class='line'>  <span class="n">defrecordp</span> <span class="ss">:tree</span><span class="p">,</span> <span class="bp">__MODULE__</span><span class="p">,</span> <span class="ss">value:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">left:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">right:</span> <span class="no">nil</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">new</span><span class="p">()</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="n">tree</span><span class="p">()</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">from_enum</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="no">Enum</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">do_from_enum</span><span class="p">()</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">defp</span> <span class="n">do_from_enum</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="n">count</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="k">do</span>
</span><span class='line'><span class="k">      </span><span class="n">middle</span> <span class="o">=</span> <span class="n">div</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span> <span class="n">left</span><span class="p">,</span> <span class="n">rest</span> <span class="p">}</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">middle</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span> <span class="p">[</span><span class="n">value</span><span class="p">],</span> <span class="n">right</span> <span class="p">}</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
</span><span class='line'>      <span class="n">tree</span><span class="p">(</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">do_from_enum</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="ss">right:</span> <span class="n">do_from_enum</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="no">nil</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="n">acc</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="p">[</span><span class="n">value</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="ss">:value</span><span class="p">,</span> <span class="ss">:left</span><span class="p">,</span> <span class="ss">:right</span><span class="p">])</span>
</span><span class='line'>    <span class="n">acc1</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</span><span class='line'>    <span class="n">acc2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc1</span><span class="p">)</span>
</span><span class='line'>    <span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span> <span class="k">do</span>
</span><span class='line'><span class="k">  def</span> <span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="n">_</span><span class="p">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="n">y</span><span class="p">,</span> <span class="n">found</span> <span class="o">-&gt;</span> <span class="n">found</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">end</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>__MODULE__</code> is a special variable that expands to the name of the module. I
could have written <code>BinTree</code> in it&rsquo;s place, but <code>__MODULE__</code> stands out and is a
good reminder of what trick is used here.</p>

<p>The module works as you&rsquo;d expect:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="no">BinTree</span><span class="o">.</span><span class="n">from_enum</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">4</span><span class="p">)</span>
</span><span class='line'><span class="c1"># {BinTree, 3, {BinTree, 2, {BinTree, 1, nil, nil}, nil}, {BinTree, 4, nil, nil}}</span>
</span><span class='line'><span class="no">BinTree</span><span class="o">.</span><span class="n">from_enum</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">4</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</span><span class='line'><span class="c1"># 4</span>
</span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;re still showing the guts of the record through <code>inspect</code> though, but that&rsquo;s
easily changed.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defimpl</span> <span class="no">Inspect</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span> <span class="k">do</span>
</span><span class='line'><span class="k">  def</span> <span class="n">inspect</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="s2">&quot;</span><span class="err">#</span><span class="s2">&lt;BinTree </span><span class="si">#{</span><span class="n">inspect</span><span class="p">(</span><span class="no">Enum</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="no">BinTree</span><span class="o">.</span><span class="n">from_enum</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">4</span><span class="p">)</span>
</span><span class='line'><span class="c1"># #&lt;BinTree [1, 2, 3, 4]&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Just remember that we&rsquo;re only hiding the representation when pretty printed, if
you pass <code>raw: true</code> to inspect you&rsquo;ll still see the internal representation.
Due to how Erlang (and thus Elixir) works this is unavoidable, but the pretty
printing serves as a powerful reminder to the user that the internal
representation should not be relied upon.</p>

<h2>Dispatching on the record tag</h2>

<p>There is another trick I&rsquo;d like to show you. If you look at the source of the
<code>Set</code> module from the standard library most functions look like this:</p>

<figure class='code'><figcaption><span>A Set function</span><a href='https://github.com/elixir-lang/elixir/blob/87be134a5b91773643ea292b521c9a8ec8167894/lib/elixir/lib/set.ex#L77-L79'>link</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">def</span> <span class="n">difference</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="n">target</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Huh? Object-oriented programming. Nope, just plain old <code>apply/3</code> (if the first
argument is not a literal symbol Elixir translates this to runtime apply call).
The magic is in the <code>target</code> macro:</p>

<figure class='code'><figcaption><span>target macro</span><a href='https://github.com/elixir-lang/elixir/blob/87be134a5b91773643ea292b521c9a8ec8167894/lib/elixir/lib/set.ex#L39-L47'>link</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmacrop</span> <span class="n">target</span><span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="kn">quote</span> <span class="k">do</span>
</span><span class='line'><span class="k">    if</span> <span class="n">is_tuple</span><span class="p">(</span><span class="kn">unquote</span><span class="p">(</span><span class="n">set</span><span class="p">))</span> <span class="k">do</span>
</span><span class='line'><span class="k">      </span><span class="n">elem</span><span class="p">(</span><span class="kn">unquote</span><span class="p">(</span><span class="n">set</span><span class="p">),</span> <span class="m">0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">unsupported_set</span><span class="p">(</span><span class="kn">unquote</span><span class="p">(</span><span class="n">set</span><span class="p">))</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Remember that the first field of a record is the tag, so <code>elem(rec, 0)</code> extracts
the record tag. If you call <code>Set.difference(s1, s2)</code> (where <code>s1</code> and <code>s2</code> are
HashSets) <code>target(s1).difference(s1, s2)</code> gets called, which expands to
(ignoring the tuple check) <code>elem(s1, 0).difference(s1, s2)</code>, which effectively
translates to <code>apply(HashSet, :difference, [s1, s2])</code>.</p>

<p>When I first saw that code I spent some time scratching my head over why they
didn&rsquo;t use a protocol. I&rsquo;m still not 100% sure, but I strongly suspect
performance is one of the main reasons. As a test I made a very simple benchmark
to compare the overhead of calling through a protocol vs calling through
<code>apply</code>.</p>

<div><script src='https://gist.github.com/2b125e2165713ec49c86.js'></script>
<noscript><pre><code></code></pre></noscript></div>


<p>Running this a number of times gives a pretty consistent result after the first
few runs: the protocol calls are about 14-15 times slower than the dispatch
calls (which is how I named the &ldquo;through apply&rdquo; calls, not sure if it&rsquo;s the
right term).</p>

<p>Now protocol calls are known to be slow (that&rsquo;s a big part of why Elixir has
reduce based collections, those only require a few protocol calls even for
large amounts of data). There are
<a href="https://github.com/elixir-lang/elixir/issues/950">ideas</a> on how to fix that and
once those get implemented things may change for released code. For now however
indirect calls through <code>apply</code> are significantly faster.</p>

<figure class='code'><figcaption><span>Set&#8217;s callbacks</span><a href='https://github.com/elixir-lang/elixir/blob/87be134a5b91773643ea292b521c9a8ec8167894/lib/elixir/lib/set.ex#L20-L37'>link</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="kn">use</span> <span class="no">Behaviour</span>
</span><span class='line'>
</span><span class='line'><span class="nv">@type</span> <span class="n">value</span> <span class="p">::</span> <span class="n">any</span>
</span><span class='line'><span class="nv">@type</span> <span class="n">values</span> <span class="p">::</span> <span class="p">[</span> <span class="n">value</span> <span class="p">]</span>
</span><span class='line'><span class="nv">@type</span> <span class="n">t</span> <span class="p">::</span> <span class="n">tuple</span>
</span><span class='line'>
</span><span class='line'><span class="n">defcallback</span> <span class="n">delete</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">difference</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">disjoint?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">boolean</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">empty</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">equal?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">boolean</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">intersection</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">member?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">::</span> <span class="n">boolean</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">put</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">size</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">non_neg_integer</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">subset?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">boolean</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">to_list</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">list</span><span class="p">()</span>
</span><span class='line'><span class="n">defcallback</span> <span class="n">union</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">::</span> <span class="n">t</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you look at <code>Set</code> again notice that it&rsquo;s a behaviour with callbacks of the
same types and arity for each exposed function. All the implementation modules
(just <code>HashSet</code> in the standard library) implement the <code>Set</code> behaviour and the
compiler makes sure that all the functions are indeed implemented. If you&rsquo;re
going to do the same protocol replacing trick as <code>Set</code> it&rsquo;s a good idea to
define a behaviour as well.</p>

<h2>Caveats</h2>

<p>So what are the downsides of the abstract data structure technique? Well you
lose the nice record syntax and decomposition and have to work with the macros
<code>defrecordp</code> generates for you. And it&rsquo;s a bit more work getting everything set
up.</p>

<p>But let&rsquo;s face it, those are minor issues. What you get is the ability to
offer a data structure without exposing it&rsquo;s representation. You get the ability
to make a data structure that (ugly hacks aside) can only be manipulated through
the API you provide, an API that maintains the internal invariants.</p>

<p>If you define a public record stop and think for a moment why you are defining
the record that way, because often hiding it in a module results in cleaner,
more maintainable code.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/11/elixir-patterns-mixins/">Elixir Patterns: Mixins</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-11T13:48:00+02:00" pubdate data-updated="true">Sep 11<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Elixir&rsquo;s macros are a powerful way to add language features without encoding
them in the language core itself. One of such features is a pattern one could
call &ldquo;mixin&rdquo; (by analogy to the
<a href="https://en.wikipedia.org/wiki/Mixin">Mixin concept</a> in class based
object-oriented languages.</p>

<p>In Ruby mixin modules are used for example to define the <code>==</code>, <code>&lt;</code>, <code>&gt;=</code>, etc
operators for a class if the <code>&lt;=&gt;</code> (compare) operator is defined. The compare
operator returns -1 if the first argument is smaller than the second, 0
if it is equal to the second and 1 if it is greater than the second. Obviously
if you have that it&rsquo;s easy to define <code>&lt;</code> and friends. By including the
<code>Comparable</code> mixin you get most of the comparison operators for free, just
remember to define <code>&lt;=&gt;</code>.</p>

<h2>Default functions for protocols</h2>

<p>In Elixir we don&rsquo;t have classes but we do have similar situations where you
generally want to define something in terms of something else. Take for example
<code>Enumerable</code>. The <code>Enumerable</code> protocol has three methods: <code>reduce/3</code>, <code>count/1</code>
and <code>member?/2</code>. However you can always define <code>count</code> and <code>member?</code> in
terms of <code>reduce</code>, they&rsquo;re just there so that you can override them with a more
efficient implementation.</p>

<p>Because protocols don&rsquo;t support default definitions for a method you always have
to define all three, even if you don&rsquo;t do anything special for <code>count</code> and
<code>member?</code>. That is to say for a simple binary tree you have to write:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defrecord</span> <span class="no">BinTree</span><span class="p">,</span> <span class="ss">value:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">left:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">right:</span> <span class="no">nil</span>

<span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span> <span class="k">do</span>
<span class="k">  def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">acc</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">acc1</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
    <span class="n">acc2</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc1</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
    <span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">count</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>Using a mixin we can simplify this. A mixin in Elixir is generally defined as a
module with a <code>__using__</code> macro.</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">Enumerable</span><span class="o">.</span><span class="no">Mixin</span> <span class="k">do</span>
<span class="k">  defmacro</span> <span class="n">__using__</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="kn">quote</span> <span class="ss">location:</span> <span class="n">keep</span> <span class="k">do</span>
<span class="k">      def</span> <span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">        </span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">        </span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="k">end</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>By simply writing <code>use Enumerable.Mixin</code> we now get <code>count</code> and <code>member?</code>
defined in our module. The argument to <code>__using__</code> we&rsquo;re ignoring is a list of
keywords that you can use with <code>use</code>, for example <code>use ExUnit.TestCase, async:
true</code>.</p>

<p>With the mixin our code becomes simpler:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span> <span class="k">do</span>
<span class="k">  </span><span class="kn">use</span> <span class="no">Enumerable</span><span class="o">.</span><span class="no">Mixin</span>
  
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">acc</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">acc1</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
    <span class="n">acc2</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc1</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
    <span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>Certainly an improvement. But what if we want to define one of the methods we
generated. For example if our binary tree has the invariant &ldquo;left.value &lt; value
&lt; right.value&rdquo; we can use that for faster member testing.</p>

<p>To support this we&rsquo;ll mark the mixed in functions as overridable. That means
that if the compiler comes across a new definition for the function (i.e.
function clauses that aren&rsquo;t right next to previous clauses of the function) it
will not complain but forget about the old definition of the function and use
the new one.</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">Enumerable</span><span class="o">.</span><span class="no">Mixin</span> <span class="k">do</span>
<span class="k">  defmacro</span> <span class="n">__using__</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="kn">quote</span> <span class="ss">location:</span> <span class="n">keep</span> <span class="k">do</span>
<span class="k">      def</span> <span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">        </span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">        </span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="k">end</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="n">defoverridable</span> <span class="p">[</span><span class="ss">count:</span> <span class="m">1</span><span class="p">,</span> <span class="ss">member?:</span> <span class="m">2</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>The arguments to <code>defoverridable</code> are the function names and arities of the
functions you want to be overridable. Now that <code>member?</code> is overridable we can
define a new custom <code>member?</code>:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span> <span class="k">do</span>
<span class="k">  </span><span class="kn">use</span> <span class="no">Enumerable</span><span class="o">.</span><span class="no">Mixin</span>
  
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">acc</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">acc1</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
    <span class="n">acc2</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc1</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
    <span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">false</span>
  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    cond</span> <span class="k">do</span>
<span class="k">      </span><span class="n">x</span> <span class="o">==</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="no">true</span>
      <span class="n">x</span> <span class="o">&lt;</span> <span class="n">value</span>  <span class="o">-&gt;</span> <span class="n">member?</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
      <span class="n">x</span> <span class="o">&gt;</span> <span class="n">value</span>  <span class="o">-&gt;</span> <span class="n">member?</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>Now our <code>member?</code> is much faster, assuming a balanced tree of 1024 nodes it only
takes 10 steps instead of 1024 steps.</p>

<h2>Behaviours</h2>

<p>Another place where mixins come in handy is in OTP style behaviours. Take a look
at a (slightly edited) bit of GenServer.Behaviour:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">GenServer</span><span class="o">.</span><span class="no">Behaviour</span>
  <span class="k">defmacro</span> <span class="n">__using__</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="kn">quote</span> <span class="ss">location:</span> <span class="ss">:keep</span> <span class="k">do</span>
<span class="k">      </span><span class="nv">@behavior</span> <span class="ss">:gen_server</span>

      <span class="k">def</span> <span class="n">init</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">do</span>
<span class="k">        </span><span class="p">{</span> <span class="ss">:ok</span><span class="p">,</span> <span class="n">args</span> <span class="p">}</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="n">handle_call</span><span class="p">(</span><span class="n">_request</span><span class="p">,</span> <span class="n">_from</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
<span class="k">        </span><span class="p">{</span> <span class="ss">:noreply</span><span class="p">,</span> <span class="n">state</span> <span class="p">}</span>
      <span class="k">end</span>

      <span class="c1"># functions ommitted</span>

      <span class="n">defoverridable</span> <span class="p">[</span><span class="ss">init:</span> <span class="m">1</span><span class="p">,</span> <span class="ss">handle_call:</span> <span class="m">3</span><span class="p">,</span> <span class="ss">handle_info:</span> <span class="m">2</span><span class="p">,</span>
        <span class="ss">handle_cast:</span> <span class="m">2</span><span class="p">,</span> <span class="ss">terminate:</span> <span class="m">2</span><span class="p">,</span> <span class="ss">code_change:</span> <span class="m">3</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>This declares the module that uses <code>GenServer.Behaviour</code> to be a gen_server
callback module (<code>@behavior :gen_server</code>) and declares all the callbacks with
simple no-op implementations, which are overridable. The idea is that you define
just the callbacks you need without being forced to declare all of them just to
keep the compiler happy.</p>

<h2>Caveats</h2>

<p>Mixins are a great tool. But like all tools they have their specific strengths
and weaknesses. Ever tried to put a nail in a wall with a screw driver?</p>

<p>Mixins are macro&rsquo;s and as such they tend to obscure the true meaning of the
code. If you refer to a function that was introduced by a mixin people might
wonder where that function came from. Luckily <code>use</code> is fairly easy to spot so
this isn&rsquo;t such a big problem.</p>

<p>Mixins also bloat the code by placing copies of definitions in multiple files.
It&rsquo;s best to keep mixed in definitions simple, if you need something more
complicated consider factoring out the part of a function that doesn&rsquo;t need to
be in the target module into a separate function in some common module and call
that.</p>

<p>Finally badly documented mixins make understanding what goes on in the target
module much harder than it needs to be. If you write a mixin make sure you
include documentation on what functions it adds and what they do.</p>

<p>These small quibbles aside mixins are a great tool for reducing the amount of
boilerplate in modules.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/05/elixirs-enumerable/">Elixir&#8217;s Enumerable</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-05T00:00:00+02:00" pubdate data-updated="true">Sep 5<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Sometimes Elixir can be quite a pain. Often it&rsquo;s because the libraries don&rsquo;t yet
have what you need or because a feature that looks like it&rsquo;s going to do exactly
what you want turns out to be more limited than you would like (<code>|&gt;</code> I&rsquo;m looking
at you). Sometimes however the pain is of a different kind, the kind you get
from trying to understand why that seemingly logical Go move is the exact
opposite of what&rsquo;s good, the kind you get from reading about category theory,
the kind you get from trying to use the newest kind of lenses in Haskell. In
other words the kind of pain that comes from desperately trying to understand
something that seems to make no sense at all.</p>

<p>And then, after beating your head against the proverbial desk enough time, you
suddenly realize that things are starting to make sense and that it&rsquo;s actually
all quite clear.</p>

<p>Today I had one of those moments. After trying to produce a better stream design
based on functions that return a value and a replacement for themselves (think
Continuation Passing Style) I ran into a problem where my <code>Iter.to_list</code> was
much slower than <code>Enum.to_list</code>. When I asked on IRC @ericmj told me that it&rsquo;s
just not possible to make my iterator approach work fast enough and that that&rsquo;s
the reason Elixir switched to a reduce based approach. He also gave me the
excellent tip to look at Clojure&rsquo;s <a href="http://clojure.org/reducers">reducers</a>,
which was the inspiration for Elixir&rsquo;s design.</p>

<p>While the blog posts linked from Clojure&rsquo;s documentation are informative they
are (naturally) about Clojure and not everybody understands that. So here&rsquo;s an
attempt to explain things in an Elixir context.</p>

<p>This post consists of four main parts.</p>

<ul>
<li><a href="#uses">A bit about what <code>Enumerable</code>, <code>Enum</code> and <code>Stream</code> are useful for.</a></li>
<li><a href="#enum">An explanation of how <code>Enum</code> is implemented in terms of <code>Enumerable</code>.</a></li>
<li><a href="#reduce">A short dicussion on writing your own <code>reduce</code> function.</a></li>
<li><a href="#stream">An explanation of how streams are used to efficiently compose
enumerables.</a></li>
</ul>


<h2>Enumerable, Enum and Stream <a name="uses">&nbsp;</a></h2>

<p>As the user of Elixir code you will often use <code>Enum</code>, sometimes use <code>Stream</code> and
rarely implement <code>Enumerable</code>. The
<a href="http://elixir-lang.org/docs/stable/Enum.html"><code>Enum</code></a> module is where most of
Elixir&rsquo;s collection manipulation code resides. It has your basic <code>map/2</code>,
<code>filter/2</code> and <code>reduce/3</code> functions as well as stuff like <code>at/2</code> / <code>fetch/2</code>
(look up an element given an index), <code>drop/2</code> and <code>min/1</code>. Whenever you want to
do something with a collection look in <code>Enum</code> first. Often the tools you need
are there.</p>

<p>Sometimes the methods from <code>Enum</code> are somewhat inefficient. Take for example
tripling some numbers and filtering out multiples of 7 afterwards
(<code>Enum.filter_map</code> doesn&rsquo;t help here, it filters before mapping). You could
write <code>Enum.map(l, &amp;(&amp;1 * 3)) |&gt; Enum.filter(&amp;(rem(&amp;1, 7) != 0))</code> but there&rsquo;s an
inefficiency. It comes from <code>Enum.map</code> constructing a list which is immediately
&ldquo;eaten&rdquo; by <code>Enum.filter</code>.  This work is unnecessary if <code>Enum.map</code> could somehow
pass elements to <code>Enum.filter</code> one by one.</p>

<p>This is where streams come in. By simply writing <code>Stream.map(l, &amp;(&amp;1 * 3)) |&gt;
Enum.filter(&amp;(rem(&amp;1, 7) != 0))</code> the inefficiency is removed. Instead of
returning a list <code>Stream.map/2</code> returns a stream for which there is an
<code>Enumerable</code> implementation so it can be used with <code>Enum</code>. Now what <code>Stream.map</code>
does is it creates a stream that wraps an enumerable and whenever an element is
requested it fetches the element from the enumerable but before passing it along
transforms it using the function given to <code>Stream.map</code>.</p>

<p>Because all the <code>Stream</code> functions return streams sooner or later you&rsquo;ll need to
use <code>Enum</code> functions to get a list or some other value (such as a sum) out of
the stream.</p>

<p>It&rsquo;s actually pretty easy to make your own data structures work with <code>Enum</code> and
<code>Stream</code>. For that you need to define your data structure as a record and add an
<code>Enumerable</code> implementation for it.</p>

<h2>Reduce and Enum <a name="enum">&nbsp;</a></h2>

<p>The <code>reduce</code> function, also known as (left) fold in other languages, is the most
direct translation of loops like this:</p>

<div class="highlight"><pre><code class="ruby"><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span> <span class="k">do</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">i</span>
<span class="k">end</span>
<span class="c1"># a is now 3628800</span>
</code></pre></div>


<p>In Elixir we would write such a loop using <code>Enum.reduce/3</code> as:</p>

<div class="highlight"><pre><code class="elixir"><span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="m">10</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">acc</span> <span class="o">*</span> <span class="n">i</span>
<span class="k">end</span><span class="p">)</span>
<span class="c1"># returns 3628800</span>
</code></pre></div>


<p>Simple enough, isn&rsquo;t it. There&rsquo;s nothing complicated about reduce, well not
until you look at the implementation of streams.</p>

<p>Reducing works by walking down a data structure (typically a list) and to call a
function for each element. The function gets passed the element from the list
and a state value (called an accumulator) and is expected to return a new state
value, which gets passed to the function the next time it&rsquo;s called.  The initial
state value is what you pass to <code>reduce</code> as the second argument. From now on I
will refer to state values as accumulators.</p>

<p>All functions in <code>Enum</code> are conceptually based on this simple function (more on
that later). For example <code>map/2</code> can be very efficiently expressed using a reduce.
Here&rsquo;s the typical code for map:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">map</span><span class="p">([],</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="p">[]</span>
<span class="k">def</span> <span class="n">map</span><span class="p">([</span><span class="n">h</span><span class="o">|</span><span class="n">t</span><span class="p">],</span> <span class="n">f</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">|</span><span class="n">t</span><span class="p">]</span>
</code></pre></div>


<p>Err, wait a minute. That can&rsquo;t be right. This function isn&rsquo;t tail recursive and
will thus eat much more stack memory than it needs to. This is more realistic:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">map</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_map</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">[])</span>

<span class="k">defp</span> <span class="n">do_map</span><span class="p">([],</span> <span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="ss">:lists</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
<span class="k">defp</span> <span class="n">do_map</span><span class="p">([</span><span class="n">h</span><span class="o">|</span><span class="n">t</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_map</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">|</span><span class="n">acc</span><span class="p">])</span>
</code></pre></div>


<p>I&rsquo;ve used <code>:lists.reverse</code> to avoid depending on <code>Enum</code> as the point of this
example is how you could do things without <code>Enum</code>. It&rsquo;s also slightly faster (no
overhead from calling a protocol function) and the fact that it&rsquo;s restricted to
lists doesn&rsquo;t matter as we&rsquo;re working on lists anyway.</p>

<p>Now here&rsquo;s how you would write <code>map/2</code> using <code>Enumerable</code>, so it works for every
enumerable:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">map</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">do </span>
<span class="k">  </span><span class="no">Enumerable</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[],</span> <span class="k">fn</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span><span class="n">acc</span><span class="p">]</span> <span class="k">end</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="ss">:lists</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div>


<p>While superficially different this is actually a lot like the accumulator
version of map with a few differences. Firstly the recursive call to <code>do_map</code> is
gone, instead just the new accumulator is returned. Secondly there&rsquo;s no more
manual pattern matching to get the first element of the list. Instead the
<code>Enumerable.reduce</code> function passes our function an element, one at a time.</p>

<p>Read that last sentence again, it&rsquo;s key to understanding the power of reduce.
The <code>reduce</code> function is responsible for calling the function we supply with
each element. It is responsible for the how of iteration. Our function doesn&rsquo;t
need to know anything about the data structure we&rsquo;re iterating over as long as
there&rsquo;s a function that can call our function. Don&rsquo;t call us, we&rsquo;ll call you.</p>

<p>Another important function in <code>Enum</code> is <code>filter/2</code>. Again the translation is
quite obvious:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">filter</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_filter</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">[])</span>

<span class="k">defp</span> <span class="n">do_filter</span><span class="p">([],</span> <span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="ss">:lists</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
<span class="k">defp</span> <span class="n">do_filter</span><span class="p">([</span><span class="n">h</span><span class="o">|</span><span class="n">t</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="k">do </span>
<span class="k">  if</span> <span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">do_filter</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">h</span><span class="o">|</span><span class="n">acc</span><span class="p">])</span>
  <span class="k">else</span>
    <span class="n">do_filter</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">acc</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>




<div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">filter</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Enumerable</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">[],</span> <span class="k">fn</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">      </span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">|</span><span class="n">acc</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="n">acc</span>
    <span class="k">end</span>
  <span class="k">end</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="ss">:lists</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div>


<p>Just the same transformation as for map.</p>

<p>A function like <code>count/1</code> can be implemented as:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Enumerable</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div>


<p>In reality it&rsquo;s a call to <code>Enumerable.count/1</code>, one of the two extra
(non-reduce) functions on <code>Enumerable</code> (the other is <code>member?/2</code>) which are
probably there to support data structures that have a faster way of computing
them than using <code>reduce</code> (like sets). We&rsquo;ll talk a look at creating an
<code>Enumerable</code> implementation for a custom data structure in the next section.</p>

<p>As you have seen all the <code>Enum</code> functions can be easily and efficiently
implemented using <code>reduce</code>. <code>reduce</code> is quite general. It&rsquo;s also not all that
hard to implement, as we shall see.</p>

<h2>Writing a reduce function <a name="reduce">&nbsp;</a></h2>

<p>We&rsquo;ve seen how you can use <code>reduce/3</code> to do quite a lot of things. But how do
you create a reduce function? Let&rsquo;s look at a few examples. First, a data
structure (a binary tree).</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">BinTree</span> <span class="k">do</span>
<span class="k">  defrecord</span> <span class="no">Tree</span><span class="p">,</span> <span class="ss">value:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">left:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">right:</span> <span class="no">nil</span>

  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">acc</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">Tree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">acc1</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
    <span class="n">acc2</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc1</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
    <span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>To reduce a binary tree we&rsquo;ll first give the value to the passed reducer
function and then call reduce on the left and right trees. Now that we have
<code>reduce</code> it&rsquo;s easy to define an <code>Enumerable</code> implementation:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span> <span class="k">do</span>
<span class="k">  def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
  <span class="k">def</span> <span class="n">count</span><span class="p">(</span><span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="no">BinTree</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>The <code>count/1</code> and <code>member?/2</code> functions are required as part of the <code>Enumerable</code>
protocol, but you can always define them like I did. They&rsquo;re mostly useful for
when you have a faster way to compute them. For example if the tree has a
guarantee that left.value &lt; value &lt; right.value you could use that to avoid
examining the whole tree.</p>

<p>Let&rsquo;s test it:</p>

<div class="highlight"><pre><code class="elixir"><span class="n">t</span> <span class="o">=</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[</span><span class="ss">value:</span> <span class="m">1</span><span class="p">,</span> 
                 <span class="ss">left:</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[</span><span class="ss">value:</span> <span class="m">2</span><span class="p">],</span>
                 <span class="ss">right:</span> <span class="no">BinTree</span><span class="o">.</span><span class="no">Tree</span><span class="p">[</span><span class="ss">value:</span> <span class="m">3</span><span class="p">]]</span>
<span class="no">Enum</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>    <span class="c1"># returns [1, 2, 3]</span>
<span class="no">Enum</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>      <span class="c1"># returns 3</span>
<span class="no">Enum</span><span class="o">.</span><span class="n">member?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="c1"># returns true</span>
<span class="no">Enum</span><span class="o">.</span><span class="n">member?</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span> <span class="c1"># returns false</span>
</code></pre></div>


<p>Ok, time for a more complicated scenario, which I&rsquo;ll also revisit in the
section about streams to demonstrate how enumerable can be used to create very
effective pipelines. Let&rsquo;s say you have a very big file and want to read it in
blocks of 512 bytes. There&rsquo;s stuff for this in the standard library
(<code>File.stream!/2</code>, <code>IO.binstream/2</code> and more). But for the sake of learning
let&rsquo;s pretend all that isn&rsquo;t there.</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">BlockReader</span> <span class="k">do</span>
<span class="k">  defexception</span> <span class="no">ReadError</span><span class="p">,</span> <span class="ss">message:</span> <span class="no">nil</span>

  <span class="k">def</span> <span class="n">read!</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">block_size</span> <span class="o">//</span> <span class="m">512</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    fn</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span> <span class="o">-&gt;</span> <span class="n">do_read!</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">defp</span> <span class="n">do_read!</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    case</span> <span class="no">IO</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">block_size</span><span class="p">)</span> <span class="k">do</span>
<span class="k">      </span><span class="ss">:eof</span>                      <span class="o">-&gt;</span> <span class="n">acc</span>
      <span class="p">{</span><span class="ss">:error</span><span class="p">,</span> <span class="n">reason</span><span class="p">}</span>          <span class="o">-&gt;</span> <span class="k">raise</span> <span class="no">ReadError</span><span class="p">,</span> <span class="ss">message:</span> <span class="n">reason</span>
      <span class="n">data</span> <span class="ow">when</span> <span class="n">is_binary</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">do_read!</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">acc</span><span class="p">),</span> <span class="n">fun</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>Given an open file (i.e. an IO device) this will cut up a file in blocks.  It
can be used like this:</p>

<div class="highlight"><pre><code class="elixir"><span class="no">File</span><span class="o">.</span><span class="n">open!</span><span class="p">(</span><span class="s2">&quot;/tmp/some_file&quot;</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="no">BlockReader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
</code></pre></div>


<p>Quick question to see whether you&rsquo;ve been paying attention, did you notice that
<code>BlockReader.read!</code> works a bit differently than <code>BinTree.reduce</code>?</p>

<p>While <code>BinTree.reduce</code> calls the supplied function directly <code>BlockReader.read!</code>
returns a function that takes an accumulator and a reducer function. So how does
this work? Well <code>Enumerable</code> is implemented for functions. Any function that
takes two arguments, initial accumulator and function is a valid <code>Enumerable</code>.
The <code>reduce</code> implementation for functions very simple:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">function</span><span class="o">.</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</code></pre></div>


<p>In other words when a function gets passed to <code>Enum.reduce</code> all that happens is
that the function gets called with the other two arguments of <code>Enum.reduce</code>
(namely the accumulator and reducer function).</p>

<p>Besides manually writing reduce functions there are also a few functions in
<code>Stream</code> that generate them such as <code>Stream.iterate/2</code> and
<code>Stream.repeatedly/1</code>.</p>

<p>In the next section we&rsquo;ll see how streams allow us to put something between a
reduction function and the reducer.</p>

<h2>Streaming transformations <a name="stream">&nbsp;</a></h2>

<p>It&rsquo;s easy enough to write some code that computes the line count and character
count (grapheme count to be precise) of each line of a file:</p>

<div class="highlight"><pre><code class="elixir"><span class="no">File</span><span class="o">.</span><span class="n">stream!</span><span class="p">(</span><span class="s2">&quot;my_file&quot;</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">({</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">},</span> <span class="k">fn</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">{</span><span class="n">lines</span><span class="p">,</span> <span class="n">chars</span><span class="p">})</span> <span class="o">-&gt;</span> 
  <span class="p">{</span><span class="n">lines</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">chars</span> <span class="o">+</span> <span class="no">String</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">line</span><span class="p">)}</span>
<span class="k">end</span><span class="p">)</span>
</code></pre></div>


<p>But what if we want something a little more complicated, like, say, ignoring
lines that start with &lsquo;#&rsquo;? We could of course complicate the reducer function
but there&rsquo;s an alterative.</p>

<p>Streams allow us to stick something (like a map or a filter) in the middle of a
reduction pipeline.</p>

<div class="highlight"><pre><code class="elixir"><span class="no">File</span><span class="o">.</span><span class="n">stream!</span><span class="p">(</span><span class="s2">&quot;my_file&quot;</span><span class="p">)</span>
  <span class="o">|&gt;</span> <span class="no">Stream</span><span class="o">.</span><span class="n">reject</span><span class="p">(</span><span class="err">&amp;</span><span class="p">(</span><span class="no">String</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="nv">&amp;1</span><span class="p">,</span> <span class="s2">&quot;</span><span class="err">#</span><span class="s2">&quot;</span><span class="p">)))</span>
  <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">({</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">},</span> <span class="k">fn</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="p">{</span><span class="n">lines</span><span class="p">,</span> <span class="n">chars</span><span class="p">})</span> <span class="o">-&gt;</span> 
       <span class="p">{</span><span class="n">lines</span><span class="o">+</span><span class="m">1</span><span class="p">,</span> <span class="n">chars</span> <span class="o">+</span> <span class="no">String</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">line</span><span class="p">)}</span>
     <span class="k">end</span><span class="p">)</span>
</code></pre></div>


<p>Here <code>Stream.reject/2</code> (reject is filter with the condition inverted) very
efficiently filters out the lines we don&rsquo;t want, without constructing a big
intermediate list of course.</p>

<p>Streams are easy to use, you just stick them between a generator (like
<code>File.stream!</code>) and some call to an <code>Enum</code> function.</p>

<p>Most, if not all, of the time the functions in <code>Stream</code> are all you need to work
with streams. But it&rsquo;s good to know how they work under the hood. Well, it&rsquo;s a
little bit complicated I&rsquo;m afraid.</p>

<p>Let&rsquo;s start by looking at the <code>Stream.Lazy</code> record:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defrecord</span> <span class="no">Stream</span><span class="o">.</span><span class="no">Lazy</span><span class="p">,</span> <span class="ss">enumerable:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">fun:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">acc:</span> <span class="no">nil</span>
</code></pre></div>


<p>Three fields: <code>enumerable</code>, <code>fun</code> and <code>acc</code>. The <code>enumerable</code> field is due to a
pipeline <code>File.stream!("a") |&gt; Stream.map(&amp;some_fun/1) |&gt; Enum.each(&amp;IO.puts/1)</code>
being translated (by the <code>|&gt;</code> macro) to <code>Enum.each(Stream.map(File.stream!("a"),
&amp;some_fun/1), &amp;IO.puts/1)</code>, meaning that <code>Stream.map</code> wraps the result of
<code>File.stream!</code> (which is a reducer calling function, which is an enumerable,
like in our implementation). The <code>enumerable</code> field stores the enumerable passed
to <code>Stream.map</code>.</p>

<p>The <code>acc</code> field stores the accumulator for your stream. It can be <code>nil</code>, if you
don&rsquo;t have an accumulator. The <code>fun</code> field stores your stream function.</p>

<p>The stream function should always accept a reducer function (I&rsquo;ll call
this the &ldquo;inner&rdquo; reducer). If you&rsquo;re using an accumulator (the <code>acc</code> field is
specified and not <code>nil</code>) it should also accept and something commonly called
<code>nesting</code> that you only need if you want to stop streaming before the input is
done (more on that later). So a non-accumulator-using stream function should
accept an inner reducer and an accumulator-using stream function should accept
an inner reducer and <code>_nesting</code>.  If you consider this to be confusing, I fully
agree.</p>

<p>The stream function should return another function. If you&rsquo;re using an
accumulator the function should accept an entry (from the &ldquo;outer&rdquo;
generator/stream, so the input you&rsquo;re working on) and an accumulator for the
inner reducer function and return a new accumulator for it. For example here&rsquo;s
how you could implement a stream that adds 1 to each input before passing it
along.</p>

<div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">add_one</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Stream</span><span class="o">.</span><span class="no">Lazy</span><span class="p">[</span><span class="ss">enumerable:</span> <span class="n">e</span><span class="p">,</span>
              <span class="c1"># acc is nil by default</span>
              <span class="ss">fun:</span> <span class="k">fn</span><span class="p">(</span><span class="n">inner_fun</span><span class="p">)</span> <span class="o">-&gt;</span>
                <span class="k">fn</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inner_acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">inner_fun</span><span class="o">.</span><span class="p">(</span><span class="n">entry</span> <span class="o">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">inner_acc</span><span class="p">)</span> <span class="k">end</span>
              <span class="k">end</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div>


<p>If the accumulator is not <code>nil</code> you get a tuple <code>{ inner_acc, my_acc }</code> instead
of just <code>inner_acc</code> and should return a similar tuple. Take for example a
function that adds successive numbers to each value.</p>

<div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">add_increasing</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Stream</span><span class="o">.</span><span class="no">Lazy</span><span class="p">[</span><span class="ss">enumerable:</span> <span class="n">e</span><span class="p">,</span>
              <span class="ss">acc:</span> <span class="m">1</span><span class="p">,</span>
              <span class="ss">fun:</span> <span class="k">fn</span><span class="p">(</span><span class="n">inner_fun</span><span class="p">,</span> <span class="n">_nesting</span><span class="p">)</span> <span class="o">-&gt;</span>
                <span class="k">fn</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="p">{</span> <span class="n">inner_acc</span><span class="p">,</span> <span class="n">my_acc</span> <span class="p">})</span> <span class="o">-&gt;</span> 
                  <span class="p">{</span> <span class="n">inner_fun</span><span class="o">.</span><span class="p">(</span><span class="n">entry</span> <span class="o">+</span> <span class="n">my_acc</span><span class="p">,</span> <span class="n">inner_acc</span><span class="p">),</span> <span class="n">my_acc</span> <span class="o">+</span> <span class="m">1</span> <span class="p">}</span>
                <span class="k">end</span>
              <span class="k">end</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div>


<p>That&rsquo;s most of the magic of stream functions. One tiny detail remains. Remember
that weird <code>nesting</code> argument? It&rsquo;s used when you want to early abort a stream
(before the input is done). This is used in <code>Stream.take</code> and it depends on
throwing a tuple. Please don&rsquo;t write code that uses this, consider the internal
throw an implementation detail that&rsquo;s not supposed to leak. I&rsquo;m only showing it
to explain how <code>Stream</code> works internally.</p>

<div class="highlight"><pre><code class="elixir"><span class="k">def</span> <span class="n">until_second_boom</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">  </span><span class="no">Stream</span><span class="o">.</span><span class="no">Lazy</span><span class="p">[</span><span class="ss">enumerable:</span> <span class="n">e</span><span class="p">,</span>
              <span class="ss">acc:</span> <span class="m">1</span><span class="p">,</span>
              <span class="ss">fun:</span> <span class="k">fn</span><span class="p">(</span><span class="n">inner_fun</span><span class="p">,</span> <span class="n">nesting</span><span class="p">)</span> <span class="o">-&gt;</span>
                <span class="k">fn</span>
                  <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="p">{</span> <span class="n">inner_acc</span><span class="p">,</span> <span class="m">0</span> <span class="p">})</span> <span class="ow">when</span> <span class="n">entry</span> <span class="o">==</span> <span class="s2">&quot;boom&quot;</span> <span class="o">-&gt;</span>
                    <span class="k">throw</span> <span class="p">{</span> <span class="ss">:stream_lazy</span><span class="p">,</span> <span class="n">nesting</span><span class="p">,</span> <span class="n">inner_acc</span> <span class="p">}</span>
                  <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="p">{</span> <span class="n">inner_acc</span><span class="p">,</span> <span class="n">my_acc</span> <span class="p">})</span> <span class="o">-&gt;</span>
                    <span class="p">{</span> <span class="n">inner_fun</span><span class="o">.</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inner_acc</span><span class="p">),</span>
                      <span class="p">(</span><span class="k">if</span> <span class="n">entry</span> <span class="o">==</span> <span class="s2">&quot;boom&quot;</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="n">my_acc</span> <span class="o">-</span> <span class="m">1</span><span class="p">,</span> <span class="k">else</span><span class="p">:</span> <span class="n">my_acc</span><span class="p">)</span> <span class="p">}</span>
                <span class="k">end</span>
              <span class="k">end</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div>


<p>When you run this code with <code>MyMod.until_second_boom([1,2,"boom",3,"boom"]) |&gt;
Enum.to_list</code> the result is <code>[1,2,"boom",3]</code>.</p>

<p>That&rsquo;s it for <code>Stream</code>. Please note however that you&rsquo;re not supposed to write
your own streams. If you need something that&rsquo;s missing from <code>Stream</code> please
write a patch for it. That way you won&rsquo;t run the risk of something breaking if
the implementation of <code>Stream</code> is updated.</p>

<h2>Wrapping it up</h2>

<p>We&rsquo;ve seen how <code>Enumerable</code> lets you work with all kinds of data structures and
custom stream sources (<code>File.stream!</code>) through a consistent interface. With
<code>Enum</code> and <code>Stream</code> pipelines of transformations can be both expressive and
efficient.  Yet at the same time there&rsquo;s great flexibility, you can define your
own stream sources and your own stream &ldquo;consumers&rdquo;. You can even (but are not
advised to) define your own stream functions.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/09/12/elixir-patterns-abstract-data-structures/">Elixir Patterns: Abstract Data Structures</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/11/elixir-patterns-mixins/">Elixir Patterns: Mixins</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/05/elixirs-enumerable/">Elixir&#8217;s Enumerable</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Peter Minten -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
