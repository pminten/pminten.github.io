
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>A Cauldron of Black and White Stones</title>
  <meta name="author" content="Peter Minten">

  
  <meta name="description" content="Parallelization is something that comes up more and more now that processors get
more and more cores. In this blog post I will take a look at how &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://pminten.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="A Cauldron of Black and White Stones" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">A Cauldron of Black and White Stones</a></h1>
  
    <h2>Peter Minten's blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://www.duckduckgo.com/" method="get">
  <fieldset role="search">
    <input type="hidden" name="sites" value="pminten.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search&hellip;"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/10/29/parallelism-in-elixir/">Parallelism in Elixir</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-29T13:39:00+01:00" pubdate data-updated="true">Oct 29<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Parallelization is something that comes up more and more now that processors get
more and more cores. In this blog post I will take a look at how Elixir supports
parallelism.</p>

<p>First the usual lecture on parallelism and concurrency. These are often mixed
up, probably because traditionally to get parallelism you needed to work with
the tools of concurrency (threads and mutexes and all that jazz).</p>

<p>Parallelism is fundamentally about taking something you can do in a sequential
(one process/thread) program and making it faster by doing parts of it at the
same time. Concurrency on the other hand is about making things possible that
are impossible in a sequential program.</p>

<p>For example when you have a function that blocks until it receives input from
the keyboard and a function that blocks until it receives input from the network
and you want to watch for both you&rsquo;re going to need multiple threads/processes
and thus concurrency (assuming there&rsquo;s no <code>select(3)</code> or something available).</p>

<p>On the other hand it&rsquo;s easy to count the words in a giant file sequentially, in
just a single process/thread. But if you can split up the file and have multiple
workers each count part of the file and those workers can run all at the same
time (in parallel) you can get your result much faster.</p>

<p>When working with parallelism you ideally want to convert a sequential algorithm
into a parallel one <em>without changing the semantics</em>. Now the bad news, in
Elixir this will not work. In Haskell it will. Haskell has deterministic
parallelism, Elixir doesn&rsquo;t. Well, technically Haskell doesn&rsquo;t have
deterministic parallelism (that&rsquo;s simply impossible to do with how computers
work) but it&rsquo;s so good at hiding the non-determinism that for all intents and
purposes it has deterministic parallelism.</p>

<p>In Elixir we don&rsquo;t quite have it so easy as Haskell programmers. We have to make
do with the tools that Erlang gives us. Ok, that&rsquo;s perhaps not the worst fate.
Erlang supports concurrency quite well (understatement of the century) and with
concurrency we can build parallelism.</p>

<h2>A simple parallel word count</h2>

<p>Let&rsquo;s think about parallel word count. How can we implement it using the tools
of Elixir? First, consider how the algorithm works:</p>

<ol>
<li>Divide the input lines into equally sized groups.</li>
<li>For each of the groups, in parallel, count the number of words.</li>
<li>Sum the results.</li>
</ol>


<p>This is actually quite a well known pattern: divide-map-reduce. Any time you
hear somebody talk about MapReduce this is the fundamental idea behind it:
divide the work, map it to workers and reduce the results. There&rsquo;s more to it
than that of course, but fundamentally it&rsquo;s this simple.</p>

<p>Now, how can we map (pardon the pun) these steps to Elixir code? Dividing is
fairly easy, because addition is commutative (<code>a + b == b + a</code>) we can simply
split the lines into N lists like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">def</span> <span class="n">divide</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_divide</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="no">List</span><span class="o">.</span><span class="n">duplicate</span><span class="p">([],</span> <span class="n">n</span><span class="p">),</span> <span class="p">[])</span>
</span><span class='line'>
</span><span class='line'><span class="k">defp</span> <span class="n">do_divide</span><span class="p">([],</span> <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">o1</span> <span class="o">++</span> <span class="n">o2</span>
</span><span class='line'><span class="k">defp</span> <span class="n">do_divide</span><span class="p">([</span><span class="n">l</span><span class="o">|</span><span class="n">ls</span><span class="p">],</span> <span class="p">[</span><span class="n">o</span><span class="o">|</span><span class="n">o1</span><span class="p">],</span> <span class="n">o2</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_divide</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">o1</span><span class="p">,</span> <span class="p">[[</span><span class="n">l</span><span class="o">|</span><span class="n">o</span><span class="p">]</span><span class="o">|</span><span class="n">o2</span><span class="p">])</span>
</span><span class='line'><span class="k">defp</span> <span class="n">do_divide</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="p">[],</span> <span class="n">o2</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_divide</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="p">[])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Running <code>divide([1,2,3,4,5,6,7,8,9,10], 3)</code> gives <code>[[8, 5, 2], [7, 6, 1], [10,
9, 4, 3]]</code>, so the lines are neatly divided. Ok, order is weird but we&rsquo;ve already
seen that that doesn&rsquo;t matter (addition is commutative). Compared to the obvious
solution of slicing the list into equal pieces we don&rsquo;t need the length, which
means this algorithm will be easier to adapt to a form that works with any
enumerable. Mostly though it&rsquo;s because I learned functional programming in
Haskell and this algorithm works well with lazyness. :)</p>

<p>For each of these groups of lines we&rsquo;ll want to spawn a worker.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">def</span> <span class="n">parcount_spawn</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="n">master</span> <span class="o">=</span> <span class="n">self</span><span class="p">()</span>
</span><span class='line'>  <span class="no">Enum</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="k">fn</span> <span class="n">group</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="no">Process</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="k">fn</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="c1"># Gotta love closures: group is captured</span>
</span><span class='line'>      <span class="c1"># (If only I could do that so easily for the white Go groups)</span>
</span><span class='line'>      <span class="n">count</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="err">&amp;</span><span class="n">length</span><span class="p">(</span><span class="n">split_words</span><span class="p">(</span><span class="nv">&amp;1</span><span class="p">)))</span>
</span><span class='line'>              <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="err">&amp;</span><span class="p">(</span><span class="nv">&amp;1</span><span class="o">+</span><span class="nv">&amp;2</span><span class="p">))</span>
</span><span class='line'>      <span class="n">master</span> <span class="o">&lt;-</span> <span class="n">count</span>
</span><span class='line'>    <span class="k">end</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">defp</span> <span class="n">split_words</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="p">[]</span> <span class="c1"># String.split gives [&quot;&quot;] in this case</span>
</span><span class='line'><span class="k">defp</span> <span class="n">split_words</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="no">String</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Each of the workers counts the words in the lines in its group, sums them and
sends the count to the master process (the one that spawned the workers).</p>

<p>All that remains is to collect the subtotals and sum them.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">def</span> <span class="n">parcount_collect</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="m">1</span><span class="o">..</span><span class="n">n</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="n">_</span><span class="p">,</span> <span class="n">total</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="k">receive</span> <span class="k">do</span>
</span><span class='line'><span class="k">      </span><span class="n">count</span> <span class="o">-&gt;</span> <span class="n">total</span> <span class="o">+</span> <span class="n">count</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here the reduce of a range is a bit of a trick in order to go into <code>receive</code> a
specific number of times.</p>

<p>To put it all together:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">def</span> <span class="n">parcount</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="n">groups</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>  <span class="n">parcount_spawn</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
</span><span class='line'>  <span class="n">parcount_collect</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>When we pass <code>parcount(["A", "B C", " ", "D D D ", ""], 3)</code> it neatly gives us
<code>6</code>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/14/thinking-in-elixir-hide-your-messages/">Thinking in Elixir: Hide Your Messages</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-14T13:39:00+02:00" pubdate data-updated="true">Sep 14<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In this new blog series I will try to explain some of the concepts behind
programming in Elixir. This will be less practical oriented than my Elixir
Patterns series and more focussed on the big ideas of functional concurrent
programming as supported by Elixir.</p>

<h2>Interface, messages and implementation</h2>

<p>Elixir is a language in which concurrency is done by passing messages between
processes. However in practical code it&rsquo;s actually pretty rare to see explicit
message passing. For example say we&rsquo;re working on a chat server. A chat room
could be written somewhat like this, using
<a href="https://github.com/pragdave/otp_dsl">otp_dsl</a>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="k">defmodule</span> <span class="no">Chatroom</span> <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="kn">use</span> <span class="no">OtpDsl</span><span class="o">.</span><span class="no">GenServer</span><span class="p">,</span> <span class="ss">initial_state:</span> <span class="no">HashDict</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">defcall</span> <span class="n">enter</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">users</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2"> has entered the room&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># _from is secretly filled in by defcall and contains the PID of the caller</span>
</span><span class='line'>    <span class="n">reply</span><span class="p">(</span><span class="ss">:ok</span><span class="p">,</span> <span class="no">Dict</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">_from</span><span class="p">))</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">defcall</span> <span class="n">leave</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">users</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="n">d</span> <span class="o">=</span> <span class="no">Dict</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>    <span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">name</span><span class="si">}</span><span class="s2"> has left the room&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">reply</span><span class="p">(</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">defcall</span> <span class="n">message</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</span><span class='line'>    <span class="n">reply</span><span class="p">(</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">defp</span> <span class="n">send_all</span><span class="p">(</span><span class="n">users</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="no">Enum</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="no">Dict</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">users</span><span class="p">),</span> <span class="no">User</span><span class="o">.</span><span class="n">send_line</span><span class="p">(</span><span class="nv">&amp;1</span><span class="p">,</span> <span class="n">message</span><span class="p">))</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/09/14/thinking-in-elixir-hide-your-messages/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/12/elixir-patterns-abstract-data-structures/">Elixir Patterns: Abstract Data Structures</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-12T10:45:00+02:00" pubdate data-updated="true">Sep 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Wouldn&rsquo;t you like to define a data structure as a module, with the internals
hidden? Obviously you can, but because modules are not records the data
structure then can&rsquo;t be used with protocols. You could define a record and in
the <code>do</code> block put functions to manipulate it but then you&rsquo;re making it easy for
your users to use the record directly, and trample on the invariants in the
process.</p>

<h2>Record tags</h2>

<p>Luckily there is a trick. It&rsquo;s not very obvious but if you read the
documentation for <code>Kernel.defrecordp/3</code> closely there is a tag field which is
used in an example to set the tag to the name of the enclosing module. What&rsquo;s
the tag? Well in Erlang, and Elixir, records are stored as tuples with the first
field being a &ldquo;tag&rdquo; that distinguishes different records and the other fields
being the data of the record. With <code>defrecord</code> the tag is always the name of the
record module, with <code>defrecordp</code> it is the record name.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='elixir'><span class='line'><span class="n">defrecordp</span> <span class="ss">:foo</span><span class="p">,</span> <span class="ss">a:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">b:</span> <span class="no">nil</span>
</span><span class='line'><span class="c1"># name = :foo, tag = :foo, foo(a: 1, b: 2) ==&gt; { :foo, 1, 2 }</span>
</span><span class='line'><span class="n">defrecordp</span> <span class="ss">:foo</span><span class="p">,</span> <span class="ss">:bar</span><span class="p">,</span> <span class="ss">a:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">b:</span> <span class="no">nil</span>
</span><span class='line'><span class="c1"># name = :foo, tag = :bar, foo(a: 1, b: 2) ==&gt; { :bar, 1, 2 }</span>
</span></code></pre></td></tr></table></div></figure>


<p>When defining implementations of protocols the name you pass to <code>for:</code> is the
tag of the record. This makes perfect sense as the protocol doesn&rsquo;t need to know
anything about your record except how to recognize it, and that&rsquo;s what the tag
is for.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/09/12/elixir-patterns-abstract-data-structures/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/11/elixir-patterns-mixins/">Elixir Patterns: Mixins</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-11T13:48:00+02:00" pubdate data-updated="true">Sep 11<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Elixir&rsquo;s macros are a powerful way to add language features without encoding
them in the language core itself. One of such features is a pattern one could
call &ldquo;mixin&rdquo; (by analogy to the
<a href="https://en.wikipedia.org/wiki/Mixin">Mixin concept</a> in class based
object-oriented languages.</p>

<p>In Ruby mixin modules are used for example to define the <code>==</code>, <code>&lt;</code>, <code>&gt;=</code>, etc
operators for a class if the <code>&lt;=&gt;</code> (compare) operator is defined. The compare
operator returns -1 if the first argument is smaller than the second, 0
if it is equal to the second and 1 if it is greater than the second. Obviously
if you have that it&rsquo;s easy to define <code>&lt;</code> and friends. By including the
<code>Comparable</code> mixin you get most of the comparison operators for free, just
remember to define <code>&lt;=&gt;</code>.</p>

<h2>Default functions for protocols</h2>

<p>In Elixir we don&rsquo;t have classes but we do have similar situations where you
generally want to define something in terms of something else. Take for example
<code>Enumerable</code>. The <code>Enumerable</code> protocol has three methods: <code>reduce/3</code>, <code>count/1</code>
and <code>member?/2</code>. However you can always define <code>count</code> and <code>member?</code> in
terms of <code>reduce</code>, they&rsquo;re just there so that you can override them with a more
efficient implementation.</p>

<p>Because protocols don&rsquo;t support default definitions for a method you always have
to define all three, even if you don&rsquo;t do anything special for <code>count</code> and
<code>member?</code>. That is to say for a simple binary tree you have to write:</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defrecord</span> <span class="no">BinTree</span><span class="p">,</span> <span class="ss">value:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">left:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">right:</span> <span class="no">nil</span>

<span class="k">defimpl</span> <span class="no">Enumerable</span><span class="p">,</span> <span class="ss">for:</span> <span class="no">BinTree</span> <span class="k">do</span>
<span class="k">  def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">acc</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[</span><span class="ss">value:</span> <span class="n">value</span><span class="p">,</span> <span class="ss">left:</span> <span class="n">left</span><span class="p">,</span> <span class="ss">right:</span> <span class="n">right</span><span class="p">],</span> <span class="n">acc</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">acc1</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
    <span class="n">acc2</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">acc1</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
    <span class="n">reduce</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">acc2</span><span class="p">,</span> <span class="n">fun</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">count</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="no">BinTree</span><span class="p">[]</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>


<p>Using a mixin we can simplify this. A mixin in Elixir is generally defined as a
module with a <code>__using__</code> macro.</p>

<div class="highlight"><pre><code class="elixir"><span class="k">defmodule</span> <span class="no">Enumerable</span><span class="o">.</span><span class="no">Mixin</span> <span class="k">do</span>
<span class="k">  defmacro</span> <span class="n">__using__</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">do</span>
<span class="k">    </span><span class="kn">quote</span> <span class="ss">location:</span> <span class="n">keep</span> <span class="k">do</span>
<span class="k">      def</span> <span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">do</span>
<span class="k">        </span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="m">1</span> <span class="k">end</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="n">member?</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">do</span>
<span class="k">        </span><span class="n">reduce</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span> <span class="k">end</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>




</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/09/11/elixir-patterns-mixins/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/05/elixirs-enumerable/">Elixir&#8217;s Enumerable</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-05T00:00:00+02:00" pubdate data-updated="true">Sep 5<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Sometimes Elixir can be quite a pain. Often it&rsquo;s because the libraries don&rsquo;t yet
have what you need or because a feature that looks like it&rsquo;s going to do exactly
what you want turns out to be more limited than you would like (<code>|&gt;</code> I&rsquo;m looking
at you). Sometimes however the pain is of a different kind, the kind you get
from trying to understand why that seemingly logical Go move is the exact
opposite of what&rsquo;s good, the kind you get from reading about category theory,
the kind you get from trying to use the newest kind of lenses in Haskell. In
other words the kind of pain that comes from desperately trying to understand
something that seems to make no sense at all.</p>

<p>And then, after beating your head against the proverbial desk enough time, you
suddenly realize that things are starting to make sense and that it&rsquo;s actually
all quite clear.</p>

<p>Today I had one of those moments. After trying to produce a better stream design
based on functions that return a value and a replacement for themselves (think
Continuation Passing Style) I ran into a problem where my <code>Iter.to_list</code> was
much slower than <code>Enum.to_list</code>. When I asked on IRC @ericmj told me that it&rsquo;s
just not possible to make my iterator approach work fast enough and that that&rsquo;s
the reason Elixir switched to a reduce based approach. He also gave me the
excellent tip to look at Clojure&rsquo;s <a href="http://clojure.org/reducers">reducers</a>,
which was the inspiration for Elixir&rsquo;s design.</p>

<p>While the blog posts linked from Clojure&rsquo;s documentation are informative they
are (naturally) about Clojure and not everybody understands that. So here&rsquo;s an
attempt to explain things in an Elixir context.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/09/05/elixirs-enumerable/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/10/29/parallelism-in-elixir/">Parallelism in Elixir</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/14/thinking-in-elixir-hide-your-messages/">Thinking in Elixir: Hide Your Messages</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/12/elixir-patterns-abstract-data-structures/">Elixir Patterns: Abstract Data Structures</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/11/elixir-patterns-mixins/">Elixir Patterns: Mixins</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/05/elixirs-enumerable/">Elixir&#8217;s Enumerable</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Peter Minten -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
